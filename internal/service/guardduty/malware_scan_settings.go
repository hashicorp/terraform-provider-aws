// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package guardduty

import (
	"context"
	"errors"
	"strings"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/guardduty"
	awstypes "github.com/aws/aws-sdk-go-v2/service/guardduty/types"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	"github.com/hashicorp/terraform-provider-aws/internal/framework/flex"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/names"
)

// @FrameworkResource("aws_guardduty_malware_scan_settings", name="Malware Scan Settings")
func newResourceMalwareScanSettings(_ context.Context) (resource.ResourceWithConfigure, error) {
	r := &resourceMalwareScanSettings{}

	return r, nil
}

const (
	ResNameMalwareScanSettings = "Malware Scan Settings"
	errScanSettingsNotFound    = "The request is rejected because the input detectorId is not owned by the current account."
)

type resourceMalwareScanSettings struct {
	framework.ResourceWithConfigure
}

func (r *resourceMalwareScanSettings) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Attributes: map[string]schema.Attribute{
			names.AttrID: framework.IDAttribute(),
			"detector_id": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(1),
				},
			},
			"ebs_snapshot_preservation": schema.StringAttribute{
				Required: true,
				Validators: []validator.String{
					stringvalidator.OneOf(enum.Values[awstypes.EbsSnapshotPreservation]()...),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"scan_resource_criteria": schema.ListNestedBlock{
				CustomType: fwtypes.NewListNestedObjectTypeOf[scanResourceCriteriaModel](ctx),
				Validators: []validator.List{
					listvalidator.SizeAtMost(1),
				},
				NestedObject: schema.NestedBlockObject{
					Blocks: map[string]schema.Block{
						"include": scanConditionTypeBlock(ctx, scanConditionTypeBlockOpts{
							conflictsWith: path.MatchRelative().AtParent().AtName("exclude"),
						}),
						"exclude": scanConditionTypeBlock(ctx, scanConditionTypeBlockOpts{
							conflictsWith: path.MatchRelative().AtParent().AtName("include"),
						}),
					},
				},
			},
		},
	}
}

type scanConditionTypeBlockOpts struct {
	conflictsWith path.Expression
}

func scanConditionTypeBlock(ctx context.Context, opts scanConditionTypeBlockOpts) schema.ListNestedBlock {
	return schema.ListNestedBlock{
		CustomType: fwtypes.NewListNestedObjectTypeOf[scanConditionTypeModel](ctx),
		Validators: []validator.List{
			listvalidator.SizeAtLeast(1),
			listvalidator.SizeAtMost(1),
			listvalidator.ConflictsWith(opts.conflictsWith),
		},

		NestedObject: schema.NestedBlockObject{
			Blocks: map[string]schema.Block{
				"ec2_instance_tag": schema.ListNestedBlock{
					CustomType: fwtypes.NewListNestedObjectTypeOf[ec2InstanceTagScanConditionsModel](ctx),
					Validators: []validator.List{
						listvalidator.SizeAtLeast(1),
						listvalidator.SizeAtMost(1),
					},
					NestedObject: schema.NestedBlockObject{
						Blocks: map[string]schema.Block{
							"map_equals": schema.ListNestedBlock{
								CustomType: fwtypes.NewListNestedObjectTypeOf[scanConditionPairModel](ctx),
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
									listvalidator.UniqueValues(),
								},
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										names.AttrKey: schema.StringAttribute{
											Required: true,
											Validators: []validator.String{
												stringvalidator.LengthBetween(1, 128),
											},
										},
										names.AttrValue: schema.StringAttribute{
											Optional: true,
											Validators: []validator.String{
												stringvalidator.LengthAtMost(256),
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *resourceMalwareScanSettings) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	conn := r.Meta().GuardDutyClient(ctx)
	var plan malwareScanSettingsResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	input, diags := expandMalwareScanSettings(ctx, plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	_, err := conn.UpdateMalwareScanSettings(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError(
			create.ProblemStandardMessage(names.GuardDuty, create.ErrActionUpdating, ResNameMalwareScanSettings, plan.DetectorID.ValueString(), err),
			err.Error(),
		)
		return
	}

	out, err := GetMalwareScanSettingsForDetector(ctx, conn, plan.DetectorID.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			create.ProblemStandardMessage(names.GuardDuty, create.ErrActionSetting, ResNameMalwareScanSettings, plan.DetectorID.ValueString(), err),
			err.Error(),
		)
		return
	}

	model, diags := flattenMalwareScanSettings(ctx, plan.DetectorID.ValueString(), out)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &model)...)
}

func (r *resourceMalwareScanSettings) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	conn := r.Meta().GuardDutyClient(ctx)
	var state malwareScanSettingsResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	out, err := GetMalwareScanSettingsForDetector(ctx, conn, state.DetectorID.ValueString())
	if tfresource.NotFound(err) {
		resp.State.RemoveResource(ctx)
		return
	}
	if err != nil {
		resp.Diagnostics.AddError(
			create.ProblemStandardMessage(names.GuardDuty, create.ErrActionSetting, ResNameMalwareScanSettings, state.DetectorID.ValueString(), err),
			err.Error(),
		)
		return
	}

	model, diags := flattenMalwareScanSettings(ctx, state.DetectorID.ValueString(), out)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &model)...)
}

func (r *resourceMalwareScanSettings) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	conn := r.Meta().GuardDutyClient(ctx)
	var plan malwareScanSettingsResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	input, diags := expandMalwareScanSettings(ctx, plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	_, err := conn.UpdateMalwareScanSettings(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError(
			create.ProblemStandardMessage(names.GuardDuty, create.ErrActionUpdating, ResNameMalwareScanSettings, plan.DetectorID.ValueString(), err),
			err.Error(),
		)
		return
	}

	out, err := GetMalwareScanSettingsForDetector(ctx, conn, plan.DetectorID.ValueString())
	if err != nil {
		resp.Diagnostics.AddError(
			create.ProblemStandardMessage(names.GuardDuty, create.ErrActionSetting, ResNameMalwareScanSettings, plan.DetectorID.ValueString(), err),
			err.Error(),
		)
		return
	}

	model, diags := flattenMalwareScanSettings(ctx, plan.DetectorID.ValueString(), out)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &model)...)
}

func (r *resourceMalwareScanSettings) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	conn := r.Meta().GuardDutyClient(ctx)
	var state malwareScanSettingsResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// reset to default settings on destroy
	input := &guardduty.UpdateMalwareScanSettingsInput{
		DetectorId:              flex.StringFromFramework(ctx, state.DetectorID),
		EbsSnapshotPreservation: awstypes.EbsSnapshotPreservationNoRetention,
		ScanResourceCriteria:    &awstypes.ScanResourceCriteria{},
	}

	_, err := conn.UpdateMalwareScanSettings(ctx, input)
	if err != nil {
		var nfe *awstypes.ResourceNotFoundException
		if errors.As(err, &nfe) {
			return
		}
		resp.Diagnostics.AddError(
			create.ProblemStandardMessage(names.GuardDuty, create.ErrActionDeleting, ResNameMalwareScanSettings, state.DetectorID.ValueString(), err),
			err.Error(),
		)
	}
}

func (r *resourceMalwareScanSettings) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("detector_id"), req, resp)
}

func GetMalwareScanSettingsForDetector(ctx context.Context, conn *guardduty.Client, detectorID string) (*guardduty.GetMalwareScanSettingsOutput, error) {
	input := &guardduty.GetMalwareScanSettingsInput{
		DetectorId: aws.String(detectorID),
	}

	result, err := conn.GetMalwareScanSettings(ctx, input)
	if err != nil {
		var nfe *awstypes.ResourceNotFoundException
		if errors.As(err, &nfe) || strings.Contains(err.Error(), errScanSettingsNotFound) {
			return nil, &retry.NotFoundError{
				LastError:   err,
				LastRequest: input,
			}
		}

		return nil, err
	}

	if result == nil {
		return nil, tfresource.NewEmptyResultError(input)
	}

	return result, nil
}

// nosemgrep:ci.semgrep.framework.manual-expander-functions
func expandMalwareScanSettings(ctx context.Context, model malwareScanSettingsResourceModel) (*guardduty.UpdateMalwareScanSettingsInput, diag.Diagnostics) {
	var diags diag.Diagnostics
	input := &guardduty.UpdateMalwareScanSettingsInput{}

	input.DetectorId = flex.StringFromFramework(ctx, model.DetectorID)
	input.EbsSnapshotPreservation = awstypes.EbsSnapshotPreservation(model.EBSSnapshotPreservation.ValueString())

	if model.ScanResourceCriteria.IsNull() || model.ScanResourceCriteria.IsUnknown() || len(model.ScanResourceCriteria.Elements()) == 0 {
		return input, diags
	}

	input.ScanResourceCriteria = &awstypes.ScanResourceCriteria{}

	var scanResourceCriteria []scanResourceCriteriaModel
	diags.Append(model.ScanResourceCriteria.ElementsAs(ctx, &scanResourceCriteria, false)...)
	if diags.HasError() || len(scanResourceCriteria) == 0 {
		return input, diags
	}

	includeScanConditions, d := expandScanConditions(ctx, scanResourceCriteria[0].Include)
	diags.Append(d...)
	if diags.HasError() {
		return nil, diags
	}

	input.ScanResourceCriteria.Include = includeScanConditions

	excludeScanConditions, d := expandScanConditions(ctx, scanResourceCriteria[0].Exclude)
	diags.Append(d...)
	if diags.HasError() {
		return nil, diags
	}

	input.ScanResourceCriteria.Exclude = excludeScanConditions

	return input, diags
}

// nosemgrep:ci.semgrep.framework.manual-expander-functions
func expandScanConditions(ctx context.Context, model fwtypes.ListNestedObjectValueOf[scanConditionTypeModel]) (map[string]awstypes.ScanCondition, diag.Diagnostics) {
	var diags diag.Diagnostics
	if model.IsNull() || model.IsUnknown() || len(model.Elements()) == 0 {
		return nil, diags
	}

	var scanConditionTypes []scanConditionTypeModel
	diags.Append(model.ElementsAs(ctx, &scanConditionTypes, false)...)
	if diags.HasError() || len(scanConditionTypes) == 0 {
		return nil, diags
	}

	scanConditionsByType := map[string]awstypes.ScanCondition{}

	ec2ScanConditionsModel := scanConditionTypes[0].EC2InstanceTagConditons
	if ec2ScanConditionsModel.IsNull() || ec2ScanConditionsModel.IsUnknown() || len(ec2ScanConditionsModel.Elements()) == 0 {
		return scanConditionsByType, diags
	}

	scanConditionsByType[string(awstypes.ScanCriterionKeyEc2InstanceTag)] = awstypes.ScanCondition{}

	var ec2InstanceTagScanConditions []ec2InstanceTagScanConditionsModel
	diags.Append(ec2ScanConditionsModel.ElementsAs(ctx, &ec2InstanceTagScanConditions, false)...)
	if diags.HasError() || len(ec2InstanceTagScanConditions) == 0 {
		return scanConditionsByType, diags
	}

	ec2TagEqualsScanConditionsModel := ec2InstanceTagScanConditions[0].MapEquals
	if ec2TagEqualsScanConditionsModel.IsNull() || ec2TagEqualsScanConditionsModel.IsUnknown() || len(ec2TagEqualsScanConditionsModel.Elements()) == 0 {
		return scanConditionsByType, diags
	}

	var ec2InstanceTagEqualPairs []scanConditionPairModel
	diags.Append(ec2TagEqualsScanConditionsModel.ElementsAs(ctx, &ec2InstanceTagEqualPairs, false)...)
	if diags.HasError() {
		return scanConditionsByType, diags
	}

	sc := awstypes.ScanCondition{}
	for _, condition := range ec2InstanceTagEqualPairs {
		pair := awstypes.ScanConditionPair{
			Key:   flex.StringFromFramework(ctx, condition.Key),
			Value: flex.StringFromFramework(ctx, condition.Value),
		}
		sc.MapEquals = append(sc.MapEquals, pair)
	}

	scanConditionsByType[string(awstypes.ScanCriterionKeyEc2InstanceTag)] = sc

	return scanConditionsByType, diags
}

// nosemgrep:ci.semgrep.framework.manual-flattener-functions
func flattenMalwareScanSettings(ctx context.Context, detectorID string, output *guardduty.GetMalwareScanSettingsOutput) (malwareScanSettingsResourceModel, diag.Diagnostics) {
	var diags diag.Diagnostics
	model := malwareScanSettingsResourceModel{
		ID:         types.StringValue(detectorID),
		DetectorID: types.StringValue(detectorID),
	}

	model.EBSSnapshotPreservation = types.StringValue(string(output.EbsSnapshotPreservation))

	if isEmptyScanCriteria(output.ScanResourceCriteria) {
		model.ScanResourceCriteria = fwtypes.NewListNestedObjectValueOfNull[scanResourceCriteriaModel](ctx)
		return model, diags
	}

	includeScanConditions, d := flattenScanConditionType(ctx, output.ScanResourceCriteria.Include)
	diags.Append(d...)
	if diags.HasError() {
		return model, diags
	}

	excludeScanConditions, d := flattenScanConditionType(ctx, output.ScanResourceCriteria.Exclude)
	diags.Append(d...)
	if diags.HasError() {
		return model, diags
	}

	scanResourceCriteria := scanResourceCriteriaModel{
		Include: includeScanConditions,
		Exclude: excludeScanConditions,
	}

	scanResourceCriteriaList, d := fwtypes.NewListNestedObjectValueOfSlice(ctx, []*scanResourceCriteriaModel{&scanResourceCriteria}, nil)
	diags.Append(d...)
	if diags.HasError() {
		return model, diags
	}

	model.ScanResourceCriteria = scanResourceCriteriaList
	return model, diags
}

// nosemgrep:ci.semgrep.framework.manual-flattener-functions
func flattenScanConditionType(ctx context.Context, scanConditionsByType map[string]awstypes.ScanCondition) (fwtypes.ListNestedObjectValueOf[scanConditionTypeModel], diag.Diagnostics) {
	var diags diag.Diagnostics
	if len(scanConditionsByType) == 0 {
		return fwtypes.NewListNestedObjectValueOfNull[scanConditionTypeModel](ctx), diags
	}

	ec2InstanceTagScanConditions, ok := scanConditionsByType[string(awstypes.ScanCriterionKeyEc2InstanceTag)]
	if !ok {
		return newListNestedObjectValueOfSlice(ctx, &diags, []*scanConditionTypeModel{
			{
				EC2InstanceTagConditons: fwtypes.NewListNestedObjectValueOfNull[ec2InstanceTagScanConditionsModel](ctx),
			},
		}), diags
	}

	if len(ec2InstanceTagScanConditions.MapEquals) == 0 {
		return newListNestedObjectValueOfSlice(ctx, &diags, []*scanConditionTypeModel{
			{
				EC2InstanceTagConditons: newListNestedObjectValueOfSlice(ctx, &diags, []*ec2InstanceTagScanConditionsModel{
					{
						MapEquals: fwtypes.NewListNestedObjectValueOfNull[scanConditionPairModel](ctx),
					},
				}),
			},
		}), diags
	}

	var ec2InstanceTagEqualsConditions []*scanConditionPairModel
	for _, condition := range ec2InstanceTagScanConditions.MapEquals {
		pair := &scanConditionPairModel{
			Key: types.StringValue(*condition.Key),
		}
		if condition.Value == nil {
			pair.Value = types.StringNull()
		} else {
			pair.Value = types.StringValue(*condition.Value)
		}

		ec2InstanceTagEqualsConditions = append(ec2InstanceTagEqualsConditions, pair)
	}

	return newListNestedObjectValueOfSlice(ctx, &diags, []*scanConditionTypeModel{
		{
			EC2InstanceTagConditons: newListNestedObjectValueOfSlice(ctx, &diags, []*ec2InstanceTagScanConditionsModel{
				{
					MapEquals: newListNestedObjectValueOfSlice(ctx, &diags, ec2InstanceTagEqualsConditions),
				},
			}),
		},
	}), diags
}

func isEmptyScanCriteria(c *awstypes.ScanResourceCriteria) bool {
	return c == nil || (len(c.Include) == 0 && len(c.Exclude) == 0)
}

func newListNestedObjectValueOfSlice[T any](ctx context.Context, diags *diag.Diagnostics, slice []*T) fwtypes.ListNestedObjectValueOf[T] {
	ret, d := fwtypes.NewListNestedObjectValueOfSlice(ctx, slice, nil)
	diags.Append(d...)
	return ret
}

type malwareScanSettingsResourceModel struct {
	ID                      types.String                                               `tfsdk:"id"`
	DetectorID              types.String                                               `tfsdk:"detector_id"`
	EBSSnapshotPreservation types.String                                               `tfsdk:"ebs_snapshot_preservation"`
	ScanResourceCriteria    fwtypes.ListNestedObjectValueOf[scanResourceCriteriaModel] `tfsdk:"scan_resource_criteria"`
}

type scanResourceCriteriaModel struct {
	Include fwtypes.ListNestedObjectValueOf[scanConditionTypeModel] `tfsdk:"include"`
	Exclude fwtypes.ListNestedObjectValueOf[scanConditionTypeModel] `tfsdk:"exclude"`
}

type scanConditionTypeModel struct {
	EC2InstanceTagConditons fwtypes.ListNestedObjectValueOf[ec2InstanceTagScanConditionsModel] `tfsdk:"ec2_instance_tag"`
}

type ec2InstanceTagScanConditionsModel struct {
	MapEquals fwtypes.ListNestedObjectValueOf[scanConditionPairModel] `tfsdk:"map_equals"`
}

type scanConditionPairModel struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}
