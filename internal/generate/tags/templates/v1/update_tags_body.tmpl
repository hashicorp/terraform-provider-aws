// {{ .UpdateTagsFunc }} updates {{ .ServicePackage }} service tags.
// The identifier is typically the Amazon Resource Name (ARN), although
// it may also be a different identifier depending on the service.
{{if  .TagTypeAddBoolElem -}}
func {{ .UpdateTagsFunc }}(ctx context.Context, conn {{ .ClientType }}, identifier{{ if .TagResTypeElem }}, resourceType{{ end }} string, oldTagsSet, newTagsSet any) error {
	oldTags := KeyValueTags(ctx, oldTagsSet, identifier{{ if .TagResTypeElem }}, resourceType{{ end }})
	newTags := KeyValueTags(ctx, newTagsSet, identifier{{ if .TagResTypeElem }}, resourceType{{ end }})
{{- else -}}
func {{ .UpdateTagsFunc }}(ctx context.Context, conn {{ .ClientType }}, identifier{{ if .TagResTypeElem }}, resourceType{{ end }} string, oldTagsMap, newTagsMap any) error {
	oldTags := tftags.New(ctx, oldTagsMap)
	newTags := tftags.New(ctx, newTagsMap)
{{- end }}
	{{- if eq (.TagOp) (.UntagOp) }}
	removedTags := oldTags.Removed(newTags).IgnoreSystem(names.{{ .ProviderNameUpper }})
	updatedTags := oldTags.Updated(newTags).IgnoreSystem(names.{{ .ProviderNameUpper }})

	// Ensure we do not send empty requests
	if len(removedTags) == 0 && len(updatedTags) == 0 {
		return nil
	}

	input := &{{ .TagPackage }}.{{ .TagOp }}Input{
		{{- if not ( .TagTypeIDElem ) }}
		{{- if .TagInIDNeedSlice }}
		{{ .TagInIDElem }}:   aws.StringSlice([]string{identifier}),
		{{- else }}
		{{ .TagInIDElem }}:   aws.String(identifier),
		{{- end }}
		{{- if .TagResTypeElem }}
		{{ .TagResTypeElem }}:      aws.String(resourceType),
		{{- end }}
		{{- end }}
	}

	if len(updatedTags) > 0 {
		input.{{ .TagInTagsElem }} = Tags(updatedTags)
	}

	if len(removedTags) > 0 {
		{{- if .UntagInNeedTagType }}
		input.{{ .UntagInTagsElem }} = Tags(removedTags)
		{{- else if .UntagInNeedTagKeyType }}
		input.{{ .UntagInTagsElem }} = TagKeys(removedTags)
		{{- else if .UntagInCustomVal }}
		input.{{ .UntagInTagsElem }} = {{ .UntagInCustomVal }}
		{{- else }}
		input.{{ .UntagInTagsElem }} = aws.StringSlice(removedTags.Keys())
		{{- end }}
	}

	_, err := conn.{{ .TagOp }}WithContext(ctx, input)

	if err != nil {
		return fmt.Errorf("tagging resource (%s): %w", identifier, err)
	}

	{{- else }}

	if removedTags := oldTags.Removed(newTags).IgnoreSystem(names.{{ .ProviderNameUpper }}); len(removedTags) > 0 {
		{{- if .TagOpBatchSize }}
		for _, removedTags := range removedTags.Chunks({{ .TagOpBatchSize }}) {
		{{- end }}
		input := &{{ .TagPackage }}.{{ .UntagOp }}Input{
			{{- if not ( .TagTypeIDElem ) }}
			{{- if .TagInIDNeedSlice }}
			{{ .TagInIDElem }}:   aws.StringSlice([]string{identifier}),
			{{- else }}
			{{ .TagInIDElem }}:   aws.String(identifier),
			{{- end }}
			{{- if .TagResTypeElem }}
			{{ .TagResTypeElem }}: aws.String(resourceType),
			{{- end }}
			{{- end }}
			{{- if .UntagInNeedTagType }}
			{{ .UntagInTagsElem }}:       Tags(removedTags),
			{{- else if .UntagInNeedTagKeyType }}
			{{ .UntagInTagsElem }}:       TagKeys(removedTags),
			{{- else if .UntagInCustomVal }}
			{{ .UntagInTagsElem }}:       {{ .UntagInCustomVal }},
			{{- else }}
			{{ .UntagInTagsElem }}:       aws.StringSlice(removedTags.Keys()),
			{{- end }}
		}

		_, err := conn.{{ .UntagOp }}WithContext(ctx, input)

		if err != nil {
			return fmt.Errorf("untagging resource (%s): %w", identifier, err)
		}
		{{- if .TagOpBatchSize }}
		}
		{{- end }}
	}

	if updatedTags := oldTags.Updated(newTags).IgnoreSystem(names.{{ .ProviderNameUpper }}); len(updatedTags) > 0 {
		{{- if .TagOpBatchSize }}
		for _, updatedTags := range updatedTags.Chunks({{ .TagOpBatchSize }}) {
		{{- end }}
		input := &{{ .TagPackage }}.{{ .TagOp }}Input{
			{{- if not ( .TagTypeIDElem ) }}
			{{- if .TagInIDNeedSlice }}
			{{ .TagInIDElem }}: aws.StringSlice([]string{identifier}),
			{{- else }}
			{{ .TagInIDElem }}: aws.String(identifier),
			{{- end }}
			{{- if .TagResTypeElem }}
			{{ .TagResTypeElem }}:    aws.String(resourceType),
			{{- end }}
			{{- end }}
			{{- if .TagInCustomVal }}
			{{ .TagInTagsElem }}:       {{ .TagInCustomVal }},
			{{- else }}
			{{ .TagInTagsElem }}:       Tags(updatedTags),
			{{- end }}
		}

		_, err := conn.{{ .TagOp }}WithContext(ctx, input)

		if err != nil {
			return fmt.Errorf("tagging resource (%s): %w", identifier, err)
		}
		{{- if .TagOpBatchSize }}
		}
		{{- end }}
	}

	{{- end }}

	return nil
}

{{- if ne .CreateTagsFunc "" }}
// {{ .CreateTagsFunc }} creates {{ .ServicePackage }} service tags for new resources.
func {{ .CreateTagsFunc }}(ctx context.Context, conn {{ .ClientType }}, identifier{{ if .TagResTypeElem }}, resourceType{{ end }} string, tags []*{{ .TagPackage }}.{{ .TagType }}) error {
	if len(tags) == 0 {
		return nil
	}

	return  {{ .UpdateTagsFunc }}(ctx, conn, identifier{{ if .TagResTypeElem }}, resourceType{{ end }}, nil, KeyValueTags(ctx, tags))
}
{{- end }}

// {{ .UpdateTagsFunc }} updates {{ .ServicePackage }} service tags.
// It is called from outside this package.
func (p *servicePackage) {{ .UpdateTagsFunc }}(ctx context.Context, meta any, identifier{{ if .TagResTypeElem }}, resourceType{{ end }} string, oldTags, newTags any) error {
	return  {{ .UpdateTagsFunc }}(ctx, meta.(*conns.AWSClient).{{ .ProviderNameUpper }}Conn(), identifier{{ if .TagResTypeElem }}, resourceType{{ end }}, oldTags, newTags)
}
