// Code generated by internal/generate/customendsschema/main.go; DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"os"

	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
)

func endpointsSchema() *schema.Schema {
	return &schema.Schema{
		Type:     schema.TypeSet,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
      {{ range .Services -}}
        // {{ .ProviderPackage }}

        "{{ .ProviderPackage }}": {
          Type:        schema.TypeString,
          Optional:    true,
          Description: "Use this to override the default service endpoint URL",
        },
        {{ range .Aliases }}
        "{{ . }}": {
          Type:        schema.TypeString,
          Optional:    true,
          Description: "Use this to override the default service endpoint URL",
        },
        {{ end }}
      {{ end }}
      },
		},
	}
}

func expandEndpoints(_ context.Context, tfList []any) (map[string]string, diag.Diagnostics) {
	var diags diag.Diagnostics

	endpointsPath := cty.GetAttrPath("endpoints")

	if l := len(tfList); l > 1 {
		diags = append(diags, errs.NewAttributeWarningDiagnostic(
			endpointsPath,
			"Invalid Attribute Value",
			fmt.Sprintf("Attribute %q should have at most 1 element, got %d."+
				"\n\nThis will be an error in a future release.",
				errs.PathString(endpointsPath), l),
		))
	}

	endpoints := make(map[string]string)
	seen := make(map[string]bool)

	for i, tfMapRaw := range tfList {
		tfMap, ok := tfMapRaw.(map[string]any)

		if !ok {
			continue
		}

		elementPath := endpointsPath.IndexInt(i)

		for k, v := range tfMap {
			if seen[k] {
				continue
			}
			if v == "" {
				continue
			}
			switch k {
{{- range .Services -}}
      {{- if ne (len .Aliases) 0 }}
			case "{{ .ProviderPackage }}"{{ range .Aliases }}, "{{ . }}"{{ end }}:
				const pkg = "{{ .ProviderPackage }}"
				attrs := []string{"{{ .ProviderPackage }}"{{ range .Aliases }}, "{{ . }}"{{ end }} }
				for _, v := range attrs {
					seen[v] = true
				}
				count := 0
				for _, attr := range attrs {
					if v := tfMap[attr].(string); v != "" {
						count++
					}
				}
				if count > 1 {
					diags = append(diags, ConflictingEndpointsWarningDiag(elementPath, attrs...))
				}
				if endpoints[pkg] == "" {
					for _, attr := range attrs {
						if v := tfMap[attr].(string); v != "" {
							endpoints[pkg] = v
							break
						}
					}
				}
      {{ end -}}
{{ end }}

			default:
				seen[k] = true
				if endpoints[k] == "" {
					endpoints[k] = v.(string)
				}
			}
		}
	}
	if diags.HasError() {
		return nil, diags
	}

	expandEndpointsCustomEnvVars(endpoints, &diags)

	return endpoints, diags
}

func expandEndpointsCustomEnvVars(endpoints map[string]string, diags *diag.Diagnostics) {
{{- range .Services -}}
  {{-  if or .TfAwsEnvVar .DeprecatedEnvVar }}
	expandEndpointCustomEnvVars("{{ .ProviderPackage }}", "{{ .AwsEnvVar }}", "{{ .TfAwsEnvVar }}", "{{ .DeprecatedEnvVar }}", endpoints, diags)
  {{ end -}}
{{ end -}}
}

func expandEndpointCustomEnvVars(pkg, awsEnvVar, tfAwsEnvVar, deprecatedEnvVar string, endpoints map[string]string, diags *diag.Diagnostics) {
	if endpoints[pkg] == "" {
		if v := os.Getenv(awsEnvVar); v != "" {
			endpoints[pkg] = v
			return
		}

		if v := os.Getenv(tfAwsEnvVar); v != "" {
			*diags = append(*diags, DeprecatedEnvVarDiag(tfAwsEnvVar, awsEnvVar))
			endpoints[pkg] = v
			return
		}

		if v := os.Getenv(deprecatedEnvVar); v != "" {
			*diags = append(*diags, DeprecatedEnvVarDiag(deprecatedEnvVar, awsEnvVar))
			endpoints[pkg] = v
			return
		}

	}
}
