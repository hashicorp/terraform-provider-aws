---
subcategory: ""
layout: "aws"
page_title: "Terraform AWS Provider Enhanced Region Support"
description: |-
  Enhanced Region support with the Terraform AWS Provider.
---


<!-- Please do not edit this file, it is generated. -->
# Enhanced Region Support

Version 6.0.0 of the Terraform AWS Provider adds `region` to most resources making it significantly easier to manage infrastructure across AWS Regions without requiring multiple provider configurations.

<!-- TOC depthFrom:2 depthTo:2 -->

- [What's new](#whats-new)
- [What's not changing](#whats-not-changing)
- [Can I use `region` in every resource?](#can-i-use-region-in-every-resource)
- [Why make this change](#why-make-this-change)
- [How `region` works](#how-region-works)
- [Migrating from multiple provider configurations](#migrating-from-multiple-provider-configurations)
- [Before and after examples using `region`](#before-and-after-examples-using-region)
- [Non–region-aware resources](#nonregion-aware-resources)

<!-- /TOC -->

## What's new

As of v6.0.0, most existing resources, data sources, and ephemeral resources are now [Region-aware](#nonregion-aware-resources), meaning they support a new top-level `region`. This allows you to manage a resource in a Region different from the one specified in the provider configuration without requiring multiple provider blocks. See [How `region` works](#how-region-works) for details.

For example, if your provider is configured for `us-east-1`, you can now manage a VPC in `us-west-2` without defining an additional provider block:

```python
# DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
from constructs import Construct
from cdktf import TerraformStack
#
# Provider bindings are generated by running `cdktf get`.
# See https://cdk.tf/provider-generation for more details.
#
from imports.aws.vpc import Vpc
class MyConvertedCode(TerraformStack):
    def __init__(self, scope, name):
        super().__init__(scope, name)
        Vpc(self, "peer",
            cidr_block="10.1.0.0/16",
            region="us-west-2"
        )
```

## What's _not_ changing

_Pre-v6.0.0 configurations that use provider blocks per Region remain valid in v6.0.0 and are not deprecated._

You can still define the Region at the provider level using any of the existing methods—for example, through the AWS [config file](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html), [provider configuration](https://developer.hashicorp.com/terraform/language/providers/configuration), [environment variables](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#environment-variables), [shared configuration files](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#shared-configuration-and-credentials-files), or explicitly using the `provider`’s [`region`](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#region).

## Can I use `region` in every resource?

No. While most resources are now Region-aware, there are exceptions. These include a few resources that already had a `region` and resources that are inherently global. See [Non–region-aware resources](#nonregion-aware-resources).

## Why make this change

Before version 6.0.0, managing infrastructure across multiple Regions required a separate provider configuration for each Region. This approach led to complex and repetitive configurations, especially for large infrastructures—AWS currently operates in [36 Regions](https://aws.amazon.com/about-aws/global-infrastructure/), with more announced. Additionally, each provider configuration adds overhead in terms of memory and compute resources.

See the [examples](#before-and-after-examples-using-region) below for a comparison of configurations before and after introducing `region`.

## How `region` works

The new top-level `region` is [_Optional_ and _Computed_](https://developer.hashicorp.com/terraform/plugin/framework/handling-data/attributes/string#configurability), and defaults to the Region specified in the provider configuration. Its value is validated to ensure it belongs to the configured [partition](https://docs.aws.amazon.com/whitepapers/latest/aws-fault-isolation-boundaries/partitions.html). **Changing the value of `region` will force resource replacement.**

To [import](https://developer.hashicorp.com/terraform/cli/import) a resource in a specific Region, append `@<region>` to the [import ID](https://developer.hashicorp.com/terraform/language/import#import-id)—for example:

```sh
terraform import aws_vpc.test_vpc vpc-a01106c2@eu-west-1
```

## Migrating from multiple provider configurations

To migrate from a separate provider configuration for each Region to a single provider configuration block and per-resource `region` values you must ensure that Terraform state is refreshed before editing resource configuration:

1. Upgrade to v6.0.0
2. Run a Terraform apply in [refresh-only mode](https://developer.hashicorp.com/terraform/cli/commands/plan#planning-modes) -- `terraform apply -refresh-only`
3. Modify the affected resource configurations, replacing the [`provider` meta-argument](https://developer.hashicorp.com/terraform/language/meta-arguments/resource-provider) with a `region` argument

## Before and after examples using `region`

### Cross-region VPC peering

<details>
<summary>Before, Pre-v6.0.0</summary>
<p>

```python
# DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
from constructs import Construct
from cdktf import Token, TerraformStack
#
# Provider bindings are generated by running `cdktf get`.
# See https://cdk.tf/provider-generation for more details.
#
from imports.aws.data_aws_caller_identity import DataAwsCallerIdentity
from imports.aws.provider import AwsProvider
from imports.aws.vpc import Vpc
from imports.aws.vpc_peering_connection import VpcPeeringConnection
from imports.aws.vpc_peering_connection_accepter import VpcPeeringConnectionAccepterA
class MyConvertedCode(TerraformStack):
    def __init__(self, scope, name):
        super().__init__(scope, name)
        AwsProvider(self, "aws",
            region="us-east-1"
        )
        peer = AwsProvider(self, "aws_1",
            alias="peer",
            region="us-west-2"
        )
        main = Vpc(self, "main",
            cidr_block="10.0.0.0/16"
        )
        aws_vpc_peer = Vpc(self, "peer",
            cidr_block="10.1.0.0/16",
            provider=peer
        )
        data_aws_caller_identity_peer = DataAwsCallerIdentity(self, "peer_4",
            provider=peer
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        data_aws_caller_identity_peer.override_logical_id("peer")
        aws_vpc_peering_connection_peer = VpcPeeringConnection(self, "peer_5",
            auto_accept=False,
            peer_owner_id=Token.as_string(data_aws_caller_identity_peer.account_id),
            peer_region="us-west-2",
            peer_vpc_id=Token.as_string(aws_vpc_peer.id),
            vpc_id=main.id
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_vpc_peering_connection_peer.override_logical_id("peer")
        aws_vpc_peering_connection_accepter_peer =
        VpcPeeringConnectionAccepterA(self, "peer_6",
            auto_accept=True,
            provider=peer,
            vpc_peering_connection_id=Token.as_string(aws_vpc_peering_connection_peer.id)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_vpc_peering_connection_accepter_peer.override_logical_id("peer")
```

</p>
</details>

<details>
<summary>After, v6.0.0+</summary>
<p>

```python
# DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
from constructs import Construct
from cdktf import Token, TerraformStack
#
# Provider bindings are generated by running `cdktf get`.
# See https://cdk.tf/provider-generation for more details.
#
from imports.aws.provider import AwsProvider
from imports.aws.vpc import Vpc
from imports.aws.vpc_peering_connection import VpcPeeringConnection
from imports.aws.vpc_peering_connection_accepter import VpcPeeringConnectionAccepterA
class MyConvertedCode(TerraformStack):
    def __init__(self, scope, name):
        super().__init__(scope, name)
        AwsProvider(self, "aws",
            region="us-east-1"
        )
        main = Vpc(self, "main",
            cidr_block="10.0.0.0/16"
        )
        peer = Vpc(self, "peer",
            cidr_block="10.1.0.0/16",
            region="us-west-2"
        )
        aws_vpc_peering_connection_peer = VpcPeeringConnection(self, "peer_3",
            auto_accept=False,
            peer_region="us-west-2",
            peer_vpc_id=peer.id,
            vpc_id=main.id
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_vpc_peering_connection_peer.override_logical_id("peer")
        aws_vpc_peering_connection_accepter_peer =
        VpcPeeringConnectionAccepterA(self, "peer_4",
            auto_accept=True,
            region="us-west-2",
            vpc_peering_connection_id=Token.as_string(aws_vpc_peering_connection_peer.id)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_vpc_peering_connection_accepter_peer.override_logical_id("peer")
```

</p>
</details>

### KMS replica key

<details>
<summary>Before, Pre-v6.0.0</summary>
<p>

```python
# DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
from constructs import Construct
from cdktf import Token, TerraformStack
#
# Provider bindings are generated by running `cdktf get`.
# See https://cdk.tf/provider-generation for more details.
#
from imports.aws.kms_key import KmsKey
from imports.aws.kms_replica_key import KmsReplicaKey
from imports.aws.provider import AwsProvider
class MyConvertedCode(TerraformStack):
    def __init__(self, scope, name):
        super().__init__(scope, name)
        primary = AwsProvider(self, "aws",
            alias="primary",
            region="us-east-1"
        )
        AwsProvider(self, "aws_1",
            region="us-west-2"
        )
        aws_kms_key_primary = KmsKey(self, "primary",
            deletion_window_in_days=30,
            description="Multi-Region primary key",
            multi_region=True,
            provider=primary
        )
        KmsReplicaKey(self, "replica",
            deletion_window_in_days=7,
            description="Multi-Region replica key",
            primary_key_arn=Token.as_string(aws_kms_key_primary.arn)
        )
```

</p>
</details>

<details>
<summary>After, v6.0.0</summary>
<p>

```python
# DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
from constructs import Construct
from cdktf import TerraformStack
#
# Provider bindings are generated by running `cdktf get`.
# See https://cdk.tf/provider-generation for more details.
#
from imports.aws.kms_key import KmsKey
from imports.aws.kms_replica_key import KmsReplicaKey
from imports.aws.provider import AwsProvider
class MyConvertedCode(TerraformStack):
    def __init__(self, scope, name):
        super().__init__(scope, name)
        AwsProvider(self, "aws",
            region="us-west-2"
        )
        primary = KmsKey(self, "primary",
            deletion_window_in_days=30,
            description="Multi-Region primary key",
            multi_region=True,
            region="us-east-1"
        )
        KmsReplicaKey(self, "replica",
            deletion_window_in_days=7,
            description="Multi-Region replica key",
            primary_key_arn=primary.arn
        )
```

</p>
</details>

### S3 bucket replication configuration

<details>
<summary>Before, Pre-v6.0.0</summary>
<p>

```python
# DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
from constructs import Construct
from cdktf import Token, TerraformStack
#
# Provider bindings are generated by running `cdktf get`.
# See https://cdk.tf/provider-generation for more details.
#
from imports.aws.data_aws_iam_policy_document import DataAwsIamPolicyDocument
from imports.aws.iam_policy import IamPolicy
from imports.aws.iam_role import IamRole
from imports.aws.iam_role_policy_attachment import IamRolePolicyAttachment
from imports.aws.provider import AwsProvider
from imports.aws.s3_bucket import S3Bucket
from imports.aws.s3_bucket_acl import S3BucketAcl
from imports.aws.s3_bucket_replication_configuration import S3BucketReplicationConfigurationA
from imports.aws.s3_bucket_versioning import S3BucketVersioningA
class MyConvertedCode(TerraformStack):
    def __init__(self, scope, name):
        super().__init__(scope, name)
        AwsProvider(self, "aws",
            region="eu-west-1"
        )
        central = AwsProvider(self, "aws_1",
            alias="central",
            region="eu-central-1"
        )
        destination = S3Bucket(self, "destination",
            bucket="tf-test-bucket-destination-12345"
        )
        source = S3Bucket(self, "source",
            bucket="tf-test-bucket-source-12345",
            provider=central
        )
        S3BucketAcl(self, "source_bucket_acl",
            acl="private",
            bucket=source.id,
            provider=central
        )
        aws_s3_bucket_versioning_destination = S3BucketVersioningA(self, "destination_5",
            bucket=destination.id,
            versioning_configuration=S3BucketVersioningVersioningConfiguration(
                status="Enabled"
            )
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_s3_bucket_versioning_destination.override_logical_id("destination")
        aws_s3_bucket_versioning_source = S3BucketVersioningA(self, "source_6",
            bucket=source.id,
            provider=central,
            versioning_configuration=S3BucketVersioningVersioningConfiguration(
                status="Enabled"
            )
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_s3_bucket_versioning_source.override_logical_id("source")
        assume_role = DataAwsIamPolicyDocument(self, "assume_role",
            statement=[DataAwsIamPolicyDocumentStatement(
                actions=["sts:AssumeRole"],
                effect="Allow",
                principals=[DataAwsIamPolicyDocumentStatementPrincipals(
                    identifiers=["s3.amazonaws.com"],
                    type="Service"
                )
                ]
            )
            ]
        )
        replication = DataAwsIamPolicyDocument(self, "replication",
            statement=[DataAwsIamPolicyDocumentStatement(
                actions=["s3:GetReplicationConfiguration", "s3:ListBucket"],
                effect="Allow",
                resources=[source.arn]
            ), DataAwsIamPolicyDocumentStatement(
                actions=["s3:GetObjectVersionForReplication", "s3:GetObjectVersionAcl", "s3:GetObjectVersionTagging"
                ],
                effect="Allow",
                resources=["${" + source.arn + "}/*"]
            ), DataAwsIamPolicyDocumentStatement(
                actions=["s3:ReplicateObject", "s3:ReplicateDelete", "s3:ReplicateTags"
                ],
                effect="Allow",
                resources=["${" + destination.arn + "}/*"]
            )
            ]
        )
        aws_iam_policy_replication = IamPolicy(self, "replication_9",
            name="tf-iam-role-policy-replication-12345",
            policy=Token.as_string(replication.json)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_iam_policy_replication.override_logical_id("replication")
        aws_iam_role_replication = IamRole(self, "replication_10",
            assume_role_policy=Token.as_string(assume_role.json),
            name="tf-iam-role-replication-12345"
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_iam_role_replication.override_logical_id("replication")
        aws_iam_role_policy_attachment_replication = IamRolePolicyAttachment(self, "replication_11",
            policy_arn=Token.as_string(aws_iam_policy_replication.arn),
            role=Token.as_string(aws_iam_role_replication.name)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_iam_role_policy_attachment_replication.override_logical_id("replication")
        aws_s3_bucket_replication_configuration_replication =
        S3BucketReplicationConfigurationA(self, "replication_12",
            bucket=source.id,
            depends_on=[aws_s3_bucket_versioning_source],
            provider=central,
            role=Token.as_string(aws_iam_role_replication.arn),
            rule=[S3BucketReplicationConfigurationRule(
                destination=S3BucketReplicationConfigurationRuleDestination(
                    bucket=destination.arn,
                    storage_class="STANDARD"
                ),
                filter=S3BucketReplicationConfigurationRuleFilter(
                    prefix="example"
                ),
                id="examplerule",
                status="Enabled"
            )
            ]
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_s3_bucket_replication_configuration_replication.override_logical_id("replication")
```

</p>
</details>

<details>
<summary>After, v6.0.0</summary>
<p>

```python
# DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
from constructs import Construct
from cdktf import Token, TerraformStack
#
# Provider bindings are generated by running `cdktf get`.
# See https://cdk.tf/provider-generation for more details.
#
from imports.aws.data_aws_iam_policy_document import DataAwsIamPolicyDocument
from imports.aws.iam_policy import IamPolicy
from imports.aws.iam_role import IamRole
from imports.aws.iam_role_policy_attachment import IamRolePolicyAttachment
from imports.aws.provider import AwsProvider
from imports.aws.s3_bucket import S3Bucket
from imports.aws.s3_bucket_acl import S3BucketAcl
from imports.aws.s3_bucket_replication_configuration import S3BucketReplicationConfigurationA
from imports.aws.s3_bucket_versioning import S3BucketVersioningA
class MyConvertedCode(TerraformStack):
    def __init__(self, scope, name):
        super().__init__(scope, name)
        AwsProvider(self, "aws",
            region="eu-west-1"
        )
        destination = S3Bucket(self, "destination",
            bucket="tf-test-bucket-destination-12345"
        )
        source = S3Bucket(self, "source",
            bucket="tf-test-bucket-source-12345",
            region="eu-central-1"
        )
        S3BucketAcl(self, "source_bucket_acl",
            acl="private",
            bucket=source.id,
            region="eu-central-1"
        )
        aws_s3_bucket_versioning_destination = S3BucketVersioningA(self, "destination_4",
            bucket=destination.id,
            versioning_configuration=S3BucketVersioningVersioningConfiguration(
                status="Enabled"
            )
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_s3_bucket_versioning_destination.override_logical_id("destination")
        aws_s3_bucket_versioning_source = S3BucketVersioningA(self, "source_5",
            bucket=source.id,
            region="eu-central-1",
            versioning_configuration=S3BucketVersioningVersioningConfiguration(
                status="Enabled"
            )
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_s3_bucket_versioning_source.override_logical_id("source")
        assume_role = DataAwsIamPolicyDocument(self, "assume_role",
            statement=[DataAwsIamPolicyDocumentStatement(
                actions=["sts:AssumeRole"],
                effect="Allow",
                principals=[DataAwsIamPolicyDocumentStatementPrincipals(
                    identifiers=["s3.amazonaws.com"],
                    type="Service"
                )
                ]
            )
            ]
        )
        replication = DataAwsIamPolicyDocument(self, "replication",
            statement=[DataAwsIamPolicyDocumentStatement(
                actions=["s3:GetReplicationConfiguration", "s3:ListBucket"],
                effect="Allow",
                resources=[source.arn]
            ), DataAwsIamPolicyDocumentStatement(
                actions=["s3:GetObjectVersionForReplication", "s3:GetObjectVersionAcl", "s3:GetObjectVersionTagging"
                ],
                effect="Allow",
                resources=["${" + source.arn + "}/*"]
            ), DataAwsIamPolicyDocumentStatement(
                actions=["s3:ReplicateObject", "s3:ReplicateDelete", "s3:ReplicateTags"
                ],
                effect="Allow",
                resources=["${" + destination.arn + "}/*"]
            )
            ]
        )
        aws_iam_policy_replication = IamPolicy(self, "replication_8",
            name="tf-iam-role-policy-replication-12345",
            policy=Token.as_string(replication.json)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_iam_policy_replication.override_logical_id("replication")
        aws_iam_role_replication = IamRole(self, "replication_9",
            assume_role_policy=Token.as_string(assume_role.json),
            name="tf-iam-role-replication-12345"
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_iam_role_replication.override_logical_id("replication")
        aws_iam_role_policy_attachment_replication = IamRolePolicyAttachment(self, "replication_10",
            policy_arn=Token.as_string(aws_iam_policy_replication.arn),
            role=Token.as_string(aws_iam_role_replication.name)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_iam_role_policy_attachment_replication.override_logical_id("replication")
        aws_s3_bucket_replication_configuration_replication =
        S3BucketReplicationConfigurationA(self, "replication_11",
            bucket=source.id,
            depends_on=[aws_s3_bucket_versioning_source],
            region="eu-central-1",
            role=Token.as_string(aws_iam_role_replication.arn),
            rule=[S3BucketReplicationConfigurationRule(
                destination=S3BucketReplicationConfigurationRuleDestination(
                    bucket=destination.arn,
                    storage_class="STANDARD"
                ),
                filter=S3BucketReplicationConfigurationRuleFilter(
                    prefix="example"
                ),
                id="examplerule",
                status="Enabled"
            )
            ]
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_s3_bucket_replication_configuration_replication.override_logical_id("replication")
```

</p>
</details>

## Non–region-aware resources {#nonregion-aware-resources}

This section lists resources that are not Region-aware—meaning `region` has not been added to them.

Some resources, such as [IAM and STS](https://docs.aws.amazon.com/IAM/latest/UserGuide/programming.html#IAMEndpoints), are [global](https://docs.aws.amazon.com/whitepapers/latest/aws-fault-isolation-boundaries/global-services.html) and exist in all Regions within a partition.

Other resources are not Region-aware because they already had a top-level `region`, are inherently global, or because adding `region` would not be appropriate for other reasons.

### Resources deprecating `region`

The following regional resources and data sources had a top-level `region` prior to version 6.0.0. It is now deprecated and will be replaced in a future version to support the new Region-aware behavior.

* `aws_cloudformation_stack_set_instance` resource
* `aws_config_aggregate_authorization` resource
* `aws_dx_hosted_connection` resource
* `aws_region` data source
* `aws_s3_bucket` data source
* `aws_servicequotas_template` resource
* `aws_servicequotas_templates` data source
* `aws_ssmincidents_replication_set` resource and data source
* `aws_vpc_endpoint_service` data source
* `aws_vpc_peering_connection` data source

### Global services

All resources for the following services are considered _global_:

* Account Management (`aws_account_*`)
* Billing (`aws_billing_*`)
* Billing and Cost Management Data Exports (`aws_bcmdataexports_*`)
* Budgets (`aws_budgets_*`)
* CloudFront (`aws_cloudfront_*` and `aws_cloudfrontkeyvaluestore_*`)
* Cost Explorer (`aws_ce_*`)
* Cost Optimization Hub (`aws_costoptimizationhub_*`)
* Cost and Usage Report (`aws_cur_*`)
* Global Accelerator (`aws_globalaccelerator_*`)
* IAM (`aws_iam_*`, `aws_rolesanywhere_*` and `aws_caller_identity`)
* Network Manager (`aws_networkmanager_*`)
* Organizations (`aws_organizations_*`)
* Price List (`aws_pricing_*`)
* Route 53 (`aws_route53_*` and `aws_route53domains_*`)
* Route 53 ARC (`aws_route53recoverycontrolconfig_*` and `aws_route53recoveryreadiness_*`)
* Shield Advanced (`aws_shield_*`)
* User Notifications (`aws_notifications_*`)
* User Notifications Contacts (`aws_notificationscontacts_*`)
* WAF Classic (`aws_waf_*`)

### Global resources in regional services

Some regional services have a subset of resources that are global:

| Service | Type | Name |
|---|---|---|
| Backup | Resource | `aws_backup_global_settings` |
| Chime SDK Voice | Resource | `aws_chimesdkvoice_global_settings` |
| CloudTrail | Resource | `aws_cloudtrail_organization_delegated_admin_account` |
| Direct Connect | Resource | `aws_dx_gateway` |
| Direct Connect | Data Source | `aws_dx_gateway` |
| EC2 | Resource | `aws_ec2_image_block_public_access` |
| Firewall Manager | Resource | `aws_fms_admin_account` |
| IPAM | Resource | `aws_vpc_ipam_organization_admin_account` |
| QuickSight | Resource | `aws_quicksight_account_settings` |
| Resource Access Manager | Resource | `aws_ram_sharing_with_organization` |
| S3 | Data Source | `aws_canonical_user_id` |
| S3 | Resource | `aws_s3_account_public_access_block` |
| S3 | Data Source | `aws_s3_account_public_access_block` |
| Service Catalog | Resource | `aws_servicecatalog_organizations_access` |

### Meta data sources

The `aws_default_tags`, `aws_partition`, and `aws_regions` data sources are effectively global.

`region` of the `aws_arn` data source stays as-is.

### Policy Document Data Sources

Some data sources convert HCL into JSON policy documents and are effectively global:

* `aws_cloudwatch_log_data_protection_policy_document`
* `aws_ecr_lifecycle_policy_document`

<!-- cache-key: cdktf-0.20.8 input-575321eb65fe5cc7968914b54535b8d50b7b97b5668f88ce8bf11d9a995e0e04 -->