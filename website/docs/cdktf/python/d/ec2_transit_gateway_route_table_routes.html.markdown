---
subcategory: "Transit Gateway"
layout: "aws"
page_title: "AWS: aws_ec2_transit_gateway_route_table_routes"
description: |-
   Provides informations for routes of a specific transit gateway
---


<!-- Please do not edit this file, it is generated. -->
# Data Source: aws_ec2_transit_gateway_route_table_routes

Provides informations for routes of a specific transit gateway, such as state, type, cidr

## Example Usage

```python
# DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
from constructs import Construct
from cdktf import TerraformStack
#
# Provider bindings are generated by running `cdktf get`.
# See https://cdk.tf/provider-generation for more details.
#
from imports.aws.data_aws_ec2_transit_gateway_route_table_routes import DataAwsEc2TransitGatewayRouteTableRoutes
class MyConvertedCode(TerraformStack):
    def __init__(self, scope, name):
        super().__init__(scope, name)
        DataAwsEc2TransitGatewayRouteTableRoutes(self, "test",
            filter=[DataAwsEc2TransitGatewayRouteTableRoutesFilter(
                name="type",
                values=["propagated"]
            )
            ],
            transit_gateway_route_table_id=example.id
        )
```

### Complexe use case with transit gateway peering

This example allow to create a mesh of transit gateway for diffÃ©rent regions routing all traffic to on-prem VPN

```python
# DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
from cdktf import TerraformResourceLifecycle
from constructs import Construct
from cdktf import Token, Fn, TerraformIterator, TerraformStack
#
# Provider bindings are generated by running `cdktf get`.
# See https://cdk.tf/provider-generation for more details.
#
from imports.aws.data_aws_ec2_transit_gateway_route_table_routes import DataAwsEc2TransitGatewayRouteTableRoutes
from imports.aws.data_aws_ec2_transit_gateway_vpc_attachment import DataAwsEc2TransitGatewayVpcAttachment
from imports.aws.data_aws_ec2_transit_gateway_vpc_attachments import DataAwsEc2TransitGatewayVpcAttachments
from imports.aws.ec2_transit_gateway import Ec2TransitGateway
from imports.aws.ec2_transit_gateway_peering_attachment import Ec2TransitGatewayPeeringAttachment
from imports.aws.ec2_transit_gateway_peering_attachment_accepter import Ec2TransitGatewayPeeringAttachmentAccepter
from imports.aws.ec2_transit_gateway_route import Ec2TransitGatewayRoute
from imports.aws.ec2_transit_gateway_route_table import Ec2TransitGatewayRouteTable
from imports.aws.ec2_transit_gateway_route_table_association import Ec2TransitGatewayRouteTableAssociation
from imports.aws.ec2_transit_gateway_route_table_propagation import Ec2TransitGatewayRouteTablePropagation
from imports.aws.ec2_transit_gateway_vpc_attachment import Ec2TransitGatewayVpcAttachment
from imports.aws.ec2_transit_gateway_vpc_attachment_accepter import Ec2TransitGatewayVpcAttachmentAccepter
from imports.aws.provider import AwsProvider
class MyConvertedCode(TerraformStack):
    def __init__(self, scope, name):
        super().__init__(scope, name)
        eu_central1 = AwsProvider(self, "aws",
            alias="eu-central-1",
            region="eu-central-1"
        )
        aws_ec2_transit_gateway_eu_central1 = Ec2TransitGateway(self, "eu-central-1",
            default_route_table_association="disable",
            default_route_table_propagation="disable",
            provider=eu_central1
        )
        this_var = Ec2TransitGateway(self, "this",
            default_route_table_association="disable",
            default_route_table_propagation="disable"
        )
        aws_ec2_transit_gateway_peering_attachment_eu_central1 =
        Ec2TransitGatewayPeeringAttachment(self, "eu-central-1_3",
            peer_region="eu-central-1",
            peer_transit_gateway_id=Token.as_string(aws_ec2_transit_gateway_eu_central1.id),
            tags={
                "Name": "TGW mesh from eu-central-1"
            },
            transit_gateway_id=Token.as_string(Fn.lookup_nested(this_var, ["0", "id"]))
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_ec2_transit_gateway_peering_attachment_eu_central1.override_logical_id("eu-central-1")
        aws_ec2_transit_gateway_peering_attachment_accepter_eu_central1 =
        Ec2TransitGatewayPeeringAttachmentAccepter(self, "eu-central-1_4",
            provider=eu_central1,
            tags={
                "Name": "Accepter TGW peering eu-central-1"
            },
            transit_gateway_attachment_id=Token.as_string(aws_ec2_transit_gateway_peering_attachment_eu_central1.id)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_ec2_transit_gateway_peering_attachment_accepter_eu_central1.override_logical_id("eu-central-1")
        aws_ec2_transit_gateway_route_table_eu_central1 =
        Ec2TransitGatewayRouteTable(self, "eu-central-1_5",
            provider=eu_central1,
            tags=Token.as_string_map(
                Fn.merge([{
                    "Name": "wl-transit-gateway-routetable-eu-central-1"
                }, global_tags
                ])),
            transit_gateway_id=Token.as_string(aws_ec2_transit_gateway_eu_central1.id)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_ec2_transit_gateway_route_table_eu_central1.override_logical_id("eu-central-1")
        aws_ec2_transit_gateway_route_table_this = Ec2TransitGatewayRouteTable(self, "this_6",
            transit_gateway_id=my_transit_gateway_id
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_ec2_transit_gateway_route_table_this.override_logical_id("this")
        Ec2TransitGatewayRouteTableAssociation(self, "vpn",
            transit_gateway_attachment_id=Token.as_string(
                Fn.lookup_nested(aws_vpn_connection_this, ["0", "transit_gateway_attachment_id"
                ])),
            transit_gateway_route_table_id=my_transit_gateway_id_route_table
        )
        aws_ec2_transit_gateway_route_table_propagation_vpn =
        Ec2TransitGatewayRouteTablePropagation(self, "vpn_8",
            transit_gateway_attachment_id=Token.as_string(
                Fn.lookup_nested(aws_vpn_connection_this, ["0", "transit_gateway_attachment_id"
                ])),
            transit_gateway_route_table_id=Token.as_string(aws_ec2_transit_gateway_route_table_this.id)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_ec2_transit_gateway_route_table_propagation_vpn.override_logical_id("vpn")
        aws_ec2_transit_gateway_vpc_attachment_this =
        Ec2TransitGatewayVpcAttachment(self, "this_9",
            depends_on=[private, public],
            subnet_ids=Token.as_list("${[ for s in ${" + private.fqn + "} : s.id]}"),
            transit_gateway_default_route_table_association=False,
            transit_gateway_default_route_table_propagation=False,
            transit_gateway_id=Token.as_string(Fn.lookup_nested(this_var, ["0", "id"])),
            vpc_id=Token.as_string(aws_vpc_this.id)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_ec2_transit_gateway_vpc_attachment_this.override_logical_id("this")
        filtered_eu_central1 = DataAwsEc2TransitGatewayVpcAttachments(self, "filtered-eu-central-1",
            filter=[DataAwsEc2TransitGatewayVpcAttachmentsFilter(
                name="state",
                values=["pendingAcceptance", "available"]
            )
            ],
            provider=eu_central1
        )
        Ec2TransitGatewayRouteTableAssociation(self, "vpc",
            transit_gateway_attachment_id=Token.as_string(aws_ec2_transit_gateway_vpc_attachment_this.id),
            transit_gateway_route_table_id=my_transit_gateway_id_route_table
        )
        aws_ec2_transit_gateway_route_table_propagation_vpc =
        Ec2TransitGatewayRouteTablePropagation(self, "vpc_12",
            transit_gateway_attachment_id=Token.as_string(aws_ec2_transit_gateway_vpc_attachment_this.id),
            transit_gateway_route_table_id=Token.as_string(aws_ec2_transit_gateway_route_table_this.id)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_ec2_transit_gateway_route_table_propagation_vpc.override_logical_id("vpc")
        # In most cases loops should be handled in the programming language context and
        #     not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
        #     you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
        #     you need to keep this like it is.
        unit_eu_central1_for_each_iterator = TerraformIterator.from_list(
            Token.as_any(Fn.toset(filtered_eu_central1.ids)))
        unit_eu_central1 = DataAwsEc2TransitGatewayVpcAttachment(self, "unit-eu-central-1",
            id=Token.as_string(unit_eu_central1_for_each_iterator.value),
            provider=eu_central1,
            for_each=unit_eu_central1_for_each_iterator
        )
        trusted_vpc_attachments_list_eu_central1 = Fn.compact(
            Token.as_list("${[ for k, tva in ${" + unit_eu_central1.fqn + "} : contains(local.trusted_aws_accounts_ids, lookup(tva, \"vpc_owner_id\", \"\")) ? tva.id : \"\"]}"))
        trusted_vpc_attachements_eu_central1 = Fn.toset(
            Fn.sort(Token.as_list(trusted_vpc_attachments_list_eu_central1)))
        # In most cases loops should be handled in the programming language context and
        #     not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
        #     you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
        #     you need to keep this like it is.
        trusted_accounts_eu_central1_tgw_for_each_iterator =
        TerraformIterator.from_list(Token.as_any(trusted_vpc_attachements_eu_central1))
        trusted_accounts_eu_central1_tgw =
        Ec2TransitGatewayVpcAttachmentAccepter(self, "trusted_accounts_eu-central-1_tgw",
            lifecycle=TerraformResourceLifecycle(
                ignore_changes=[subnet_ids, id, dns_support, ipv6_support, transit_gateway_id, vpc_id, vpc_owner_id
                ],
                prevent_destroy=False
            ),
            provider=eu_central1,
            tags=Token.as_string_map(global_tags),
            transit_gateway_attachment_id=Token.as_string(trusted_accounts_eu_central1_tgw_for_each_iterator.value),
            transit_gateway_default_route_table_association=False,
            transit_gateway_default_route_table_propagation=False,
            for_each=trusted_accounts_eu_central1_tgw_for_each_iterator
        )
        # In most cases loops should be handled in the programming language context and
        #     not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
        #     you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
        #     you need to keep this like it is.
        trusted_accounts_eu_central1_for_each_iterator = TerraformIterator.from_list(
            Token.as_any(trusted_accounts_eu_central1_tgw))
        Ec2TransitGatewayRouteTableAssociation(self, "trusted_accounts_eu-central-1",
            provider=eu_central1,
            transit_gateway_attachment_id=Token.as_string(
                Fn.lookup_nested(trusted_accounts_eu_central1_for_each_iterator.value, ["transit_gateway_attachment_id"
                ])),
            transit_gateway_route_table_id=Token.as_string(aws_ec2_transit_gateway_route_table_eu_central1.id),
            for_each=trusted_accounts_eu_central1_for_each_iterator
        )
        # In most cases loops should be handled in the programming language context and
        #     not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
        #     you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
        #     you need to keep this like it is.
        aws_ec2_transit_gateway_route_table_propagation_trusted_accounts_eu_central1_for_each_iterator =
        TerraformIterator.from_list(Token.as_any(trusted_accounts_eu_central1_tgw))
        aws_ec2_transit_gateway_route_table_propagation_trusted_accounts_eu_central1 =
        Ec2TransitGatewayRouteTablePropagation(self, "trusted_accounts_eu-central-1_16",
            provider=eu_central1,
            transit_gateway_attachment_id=Token.as_string(
                Fn.lookup_nested(aws_ec2_transit_gateway_route_table_propagation_trusted_accounts_eu_central1_for_each_iterator.value, ["transit_gateway_attachment_id"])),
            transit_gateway_route_table_id=Token.as_string(aws_ec2_transit_gateway_route_table_eu_central1.id),
            for_each=aws_ec2_transit_gateway_route_table_propagation_trusted_accounts_eu_central1_for_each_iterator
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_ec2_transit_gateway_route_table_propagation_trusted_accounts_eu_central1.override_logical_id("trusted_accounts_eu-central-1")
        test = DataAwsEc2TransitGatewayRouteTableRoutes(self, "test",
            depends_on=[aws_ec2_transit_gateway_route_table_propagation_trusted_accounts_eu_central1
            ],
            filter=[DataAwsEc2TransitGatewayRouteTableRoutesFilter(
                name="type",
                values=["propagated"]
            )
            ],
            provider=eu_central1,
            transit_gateway_route_table_id=Token.as_string(aws_ec2_transit_gateway_route_table_eu_central1.id)
        )
        # In most cases loops should be handled in the programming language context and
        #     not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
        #     you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
        #     you need to keep this like it is.
        default_region_to_eu_central1_for_each_iterator = TerraformIterator.from_list(
            Token.as_any("${{ for r in ${" + test.routes + "} : r.destination_cidr_block => r}}"))
        Ec2TransitGatewayRoute(self, "default-region-to-eu-central-1",
            destination_cidr_block=Token.as_string(default_region_to_eu_central1_for_each_iterator.key),
            transit_gateway_attachment_id=Token.as_string(aws_ec2_transit_gateway_peering_attachment_eu_central1.id),
            transit_gateway_route_table_id=Token.as_string(aws_ec2_transit_gateway_route_table_this.id),
            for_each=default_region_to_eu_central1_for_each_iterator
        )
```

## Argument Reference

The following arguments are required:

* `filter` - (Required) Custom filter block as described below.
* `transit_gateway_route_table_id` - (Required) Identifier of EC2 Transit Gateway Route Table.

More complex filters can be expressed using one or more `filter` sub-blocks,
which take the following arguments:

* `name` - (Required) Name of the field to filter by, as defined by
  [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SearchTransitGatewayRoutes.html).
* `values` - (Required) Set of values that are accepted for the given field.

## Attributes Reference

In addition to all arguments above, the following attributes are exported:

* `id` - The transit gateway route table id suffixed by `-routes`
* `routes` - List of Transit Gateway Routes.

#### Routes list Attributes Reference

* `destination_cidr_block` - The CIDR used for route destination matches.
* `prefix_list_id` - The ID of the prefix list used for destination matches.
* `state` - The current state of the route, can be `active`, `deleted`, `pending`, `blackhole`, `deleting`.
* `transit_gateway_route_table_announcement_id` - The id of the transit gateway route table announcement, most of the time it is an empty string.
* `type` - The type of the route, can be `propagated` or `static`.

<!-- cache-key: cdktf-0.20.1 input-5fba265cc145ada0235efec26c10c79f01ec5384ee918cc84a3f6d087ffa07e0 -->