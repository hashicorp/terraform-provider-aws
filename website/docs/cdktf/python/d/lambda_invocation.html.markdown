---
subcategory: "Lambda"
layout: "aws"
page_title: "AWS: aws_lambda_invocation"
description: |-
  Invokes an AWS Lambda Function and returns its results.
---


<!-- Please do not edit this file, it is generated. -->
# Data Source: aws_lambda_invocation

Invokes an AWS Lambda Function and returns its results. Use this data source to execute Lambda functions during Terraform operations and use their results in other resources or outputs.

The Lambda function is invoked with [RequestResponse](https://docs.aws.amazon.com/lambda/latest/dg/API_Invoke.html#API_Invoke_RequestSyntax) invocation type.

~> **Note:** The `aws_lambda_invocation` data source invokes the function during the first `apply` and every subsequent `plan` when the function is known.

~> **Note:** If you get a `KMSAccessDeniedException: Lambda was unable to decrypt the environment variables because KMS access was denied` error when invoking a Lambda function with environment variables, the IAM role associated with the function may have been deleted and recreated after the function was created. You can fix the problem two ways: 1) updating the function's role to another role and then updating it back again to the recreated role, or 2) by using Terraform to `taint` the function and `apply` your configuration again to recreate the function. (When you create a function, Lambda grants permissions on the KMS key to the function's IAM role. If the IAM role is recreated, the grant is no longer valid. Changing the function's role or recreating the function causes Lambda to update the grant.)

## Example Usage

### Basic Invocation

```python
# DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
from constructs import Construct
from cdktf import Token, Fn, TerraformOutput, TerraformStack
#
# Provider bindings are generated by running `cdktf get`.
# See https://cdk.tf/provider-generation for more details.
#
from imports.aws.data_aws_lambda_invocation import DataAwsLambdaInvocation
class MyConvertedCode(TerraformStack):
    def __init__(self, scope, name):
        super().__init__(scope, name)
        example = DataAwsLambdaInvocation(self, "example",
            function_name=Token.as_string(aws_lambda_function_example.function_name),
            input=Token.as_string(
                Fn.jsonencode({
                    "id": "123456",
                    "operation": "getStatus"
                }))
        )
        TerraformOutput(self, "result",
            value=Fn.jsondecode(Token.as_string(example.result))
        )
```

### Dynamic Resource Configuration

```python
# DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
from constructs import Construct
from cdktf import Fn, Token, TerraformStack
#
# Provider bindings are generated by running `cdktf get`.
# See https://cdk.tf/provider-generation for more details.
#
from imports.aws.data_aws_lambda_invocation import DataAwsLambdaInvocation
from imports.aws.elasticache_cluster import ElasticacheCluster
class MyConvertedCode(TerraformStack):
    def __init__(self, scope, name):
        super().__init__(scope, name)
        resource_config = DataAwsLambdaInvocation(self, "resource_config",
            function_name="resource-config-generator",
            input=Token.as_string(
                Fn.jsonencode({
                    "environment": environment.value,
                    "region": current.region,
                    "service": "api"
                })),
            qualifier="production"
        )
        config = Fn.jsondecode(Token.as_string(resource_config.result))
        ElasticacheCluster(self, "example",
            cluster_id=Token.as_string(
                Fn.lookup_nested(config, ["cache", "cluster_id"])),
            engine=Token.as_string(Fn.lookup_nested(config, ["cache", "engine"])),
            node_type=Token.as_string(Fn.lookup_nested(config, ["cache", "node_type"])),
            num_cache_nodes=Token.as_number(
                Fn.lookup_nested(config, ["cache", "nodes"])),
            parameter_group_name=Token.as_string(
                Fn.lookup_nested(config, ["cache", "parameter_group"])),
            tags=Token.as_string_map(Fn.lookup_nested(config, ["tags"]))
        )
```

### Error Handling

```python
# DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
from constructs import Construct
from cdktf import Token, Fn, Op, conditional, TerraformCount, TerraformStack
#
# Provider bindings are generated by running `cdktf get`.
# See https://cdk.tf/provider-generation for more details.
#
from imports.null.resource import Resource
from imports.aws.data_aws_lambda_invocation import DataAwsLambdaInvocation
class MyConvertedCode(TerraformStack):
    def __init__(self, scope, name):
        super().__init__(scope, name)
        example = DataAwsLambdaInvocation(self, "example",
            function_name=Token.as_string(aws_lambda_function_example.function_name),
            input=Token.as_string(
                Fn.jsonencode({
                    "action": "validate",
                    "payload": configuration.value
                }))
        )
        result = Fn.jsondecode(Token.as_string(example.result))
        has_errors = Fn.try([
            Op.neq(Fn.lookup_nested(result, ["errors"]), "null"), False
        ])
        error_messages = conditional(has_errors,
            Fn.join(", ", Token.as_list(Fn.lookup_nested(result, ["errors"]))), "null")
        # In most cases loops should be handled in the programming language context and
        #     not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
        #     you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
        #     you need to keep this like it is.
        validation_check_count = TerraformCount.of(
            Token.as_number(
                conditional(has_errors,
                    fail("Configuration validation failed: ${" + error_messages + "}"), 0)))
        Resource(self, "validation_check",
            count=validation_check_count
        )
```

## Argument Reference

The following arguments are required:

* `function_name` - (Required) Name of the Lambda function.
* `input` - (Required) String in JSON format that is passed as payload to the Lambda function.

The following arguments are optional:

* `qualifier` - (Optional) Qualifier (a.k.a version) of the Lambda function. Defaults to `$LATEST`.
* `region` - (Optional) Region where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the [provider configuration](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#aws-configuration-reference).

## Attribute Reference

This data source exports the following attributes in addition to the arguments above:

* `result` - String result of the Lambda function invocation.

<!-- cache-key: cdktf-0.20.8 input-105f339332c75171eb005cb65227f6002803d5ca434b3af2ce03068b949e942d -->