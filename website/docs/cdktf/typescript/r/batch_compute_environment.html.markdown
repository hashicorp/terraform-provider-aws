---
subcategory: "Batch"
layout: "aws"
page_title: "AWS: aws_batch_compute_environment"
description: |-
  Creates a AWS Batch compute environment.
---


<!-- Please do not edit this file, it is generated. -->
# Resource: aws_batch_compute_environment

Creates a AWS Batch compute environment. Compute environments contain the Amazon ECS container instances that are used to run containerized batch jobs.

For information about AWS Batch, see [What is AWS Batch?][1] .
For information about compute environment, see [Compute Environments][2] .

~> **Note:** To prevent a race condition during environment deletion, make sure to set `dependsOn` to the related `aws_iam_role_policy_attachment`;
otherwise, the policy may be destroyed too soon and the compute environment will then get stuck in the `DELETING` state, see [Troubleshooting AWS Batch][3] .

## Example Usage

### EC2 Type

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { BatchComputeEnvironment } from "./.gen/providers/aws/batch-compute-environment";
import { DataAwsIamPolicyDocument } from "./.gen/providers/aws/data-aws-iam-policy-document";
import { IamInstanceProfile } from "./.gen/providers/aws/iam-instance-profile";
import { IamRole } from "./.gen/providers/aws/iam-role";
import { IamRolePolicyAttachment } from "./.gen/providers/aws/iam-role-policy-attachment";
import { PlacementGroup } from "./.gen/providers/aws/placement-group";
import { SecurityGroup } from "./.gen/providers/aws/security-group";
import { Subnet } from "./.gen/providers/aws/subnet";
import { Vpc } from "./.gen/providers/aws/vpc";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const sample = new PlacementGroup(this, "sample", {
      name: "sample",
      strategy: "cluster",
    });
    const awsSecurityGroupSample = new SecurityGroup(this, "sample_1", {
      egress: [
        {
          cidrBlocks: ["0.0.0.0/0"],
          fromPort: 0,
          protocol: "-1",
          toPort: 0,
        },
      ],
      name: "aws_batch_compute_environment_security_group",
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsSecurityGroupSample.overrideLogicalId("sample");
    const awsVpcSample = new Vpc(this, "sample_2", {
      cidrBlock: "10.1.0.0/16",
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsVpcSample.overrideLogicalId("sample");
    const batchAssumeRole = new DataAwsIamPolicyDocument(
      this,
      "batch_assume_role",
      {
        statement: [
          {
            actions: ["sts:AssumeRole"],
            effect: "Allow",
            principals: [
              {
                identifiers: ["batch.amazonaws.com"],
                type: "Service",
              },
            ],
          },
        ],
      }
    );
    const ec2AssumeRole = new DataAwsIamPolicyDocument(
      this,
      "ec2_assume_role",
      {
        statement: [
          {
            actions: ["sts:AssumeRole"],
            effect: "Allow",
            principals: [
              {
                identifiers: ["ec2.amazonaws.com"],
                type: "Service",
              },
            ],
          },
        ],
      }
    );
    const awsBatchServiceRole = new IamRole(this, "aws_batch_service_role", {
      assumeRolePolicy: Token.asString(batchAssumeRole.json),
      name: "aws_batch_service_role",
    });
    const ecsInstanceRole = new IamRole(this, "ecs_instance_role", {
      assumeRolePolicy: Token.asString(ec2AssumeRole.json),
      name: "ecs_instance_role",
    });
    const awsIamRolePolicyAttachmentAwsBatchServiceRole =
      new IamRolePolicyAttachment(this, "aws_batch_service_role_7", {
        policyArn: "arn:aws:iam::aws:policy/service-role/AWSBatchServiceRole",
        role: awsBatchServiceRole.name,
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamRolePolicyAttachmentAwsBatchServiceRole.overrideLogicalId(
      "aws_batch_service_role"
    );
    const awsIamRolePolicyAttachmentEcsInstanceRole =
      new IamRolePolicyAttachment(this, "ecs_instance_role_8", {
        policyArn:
          "arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role",
        role: ecsInstanceRole.name,
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamRolePolicyAttachmentEcsInstanceRole.overrideLogicalId(
      "ecs_instance_role"
    );
    const awsSubnetSample = new Subnet(this, "sample_9", {
      cidrBlock: "10.1.1.0/24",
      vpcId: Token.asString(awsVpcSample.id),
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsSubnetSample.overrideLogicalId("sample");
    const awsIamInstanceProfileEcsInstanceRole = new IamInstanceProfile(
      this,
      "ecs_instance_role_10",
      {
        name: "ecs_instance_role",
        role: ecsInstanceRole.name,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamInstanceProfileEcsInstanceRole.overrideLogicalId("ecs_instance_role");
    const awsBatchComputeEnvironmentSample = new BatchComputeEnvironment(
      this,
      "sample_11",
      {
        computeEnvironmentName: "sample",
        computeResources: {
          instanceRole: Token.asString(
            awsIamInstanceProfileEcsInstanceRole.arn
          ),
          instanceType: ["c4.large"],
          maxVcpus: 16,
          minVcpus: 0,
          placementGroup: sample.name,
          securityGroupIds: [Token.asString(awsSecurityGroupSample.id)],
          subnets: [Token.asString(awsSubnetSample.id)],
          type: "EC2",
        },
        dependsOn: [awsIamRolePolicyAttachmentAwsBatchServiceRole],
        serviceRole: awsBatchServiceRole.arn,
        type: "MANAGED",
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsBatchComputeEnvironmentSample.overrideLogicalId("sample");
  }
}

```

### Fargate Type

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { BatchComputeEnvironment } from "./.gen/providers/aws/batch-compute-environment";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new BatchComputeEnvironment(this, "sample", {
      computeEnvironmentName: "sample",
      computeResources: {
        maxVcpus: 16,
        securityGroupIds: [Token.asString(awsSecurityGroupSample.id)],
        subnets: [Token.asString(awsSubnetSample.id)],
        type: "FARGATE",
      },
      dependsOn: [awsBatchServiceRole],
      serviceRole: Token.asString(awsIamRoleAwsBatchServiceRole.arn),
      type: "MANAGED",
    });
  }
}

```

### Setting Update Policy

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { BatchComputeEnvironment } from "./.gen/providers/aws/batch-compute-environment";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new BatchComputeEnvironment(this, "sample", {
      computeEnvironmentName: "sample",
      computeResources: {
        allocationStrategy: "BEST_FIT_PROGRESSIVE",
        instanceRole: ecsInstance.arn,
        instanceType: ["optimal"],
        maxVcpus: 4,
        minVcpus: 0,
        securityGroupIds: [Token.asString(awsSecurityGroupSample.id)],
        subnets: [Token.asString(awsSubnetSample.id)],
        type: "EC2",
      },
      type: "MANAGED",
      updatePolicy: {
        jobExecutionTimeoutMinutes: 30,
        terminateJobsOnUpdate: false,
      },
    });
  }
}

```

## Argument Reference

* `computeEnvironmentName` - (Optional, Forces new resource) The name for your compute environment. Up to 128 letters (uppercase and lowercase), numbers, and underscores are allowed. If omitted, Terraform will assign a random, unique name.
* `computeEnvironmentNamePrefix` - (Optional, Forces new resource) Creates a unique compute environment name beginning with the specified prefix. Conflicts with `computeEnvironmentName`.
* `computeResources` - (Optional) Details of the compute resources managed by the compute environment. This parameter is required for managed compute environments. See details below.
* `eksConfiguration` - (Optional) Details for the Amazon EKS cluster that supports the compute environment. See details below.
* `serviceRole` - (Optional) The full Amazon Resource Name (ARN) of the IAM role that allows AWS Batch to make calls to other AWS services on your behalf.
* `state` - (Optional) The state of the compute environment. If the state is `ENABLED`, then the compute environment accepts jobs from a queue and can scale out automatically based on queues. Valid items are `ENABLED` or `DISABLED`. Defaults to `ENABLED`.
* `tags` - (Optional) Key-value map of resource tags. If configured with a provider [`defaultTags` configuration block](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#default_tags-configuration-block) present, tags with matching keys will overwrite those defined at the provider-level.
* `type` - (Required) The type of the compute environment. Valid items are `MANAGED` or `UNMANAGED`.
* `updatePolicy` - (Optional) Specifies the infrastructure update policy for the compute environment. See details below.

### compute_resources

* `allocationStrategy` - (Optional) The allocation strategy to use for the compute resource in case not enough instances of the best fitting instance type can be allocated. For valid values, refer to the [AWS documentation](https://docs.aws.amazon.com/batch/latest/APIReference/API_ComputeResource.html#Batch-Type-ComputeResource-allocationStrategy). Defaults to `BEST_FIT`. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `bidPercentage` - (Optional) Integer of maximum percentage that a Spot Instance price can be when compared with the On-Demand price for that instance type before instances are launched. For example, if your bid percentage is 20% (`20`), then the Spot price must be below 20% of the current On-Demand price for that EC2 instance. If you leave this field empty, the default value is 100% of the On-Demand price. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `desiredVcpus` - (Optional) The desired number of EC2 vCPUS in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `ec2Configuration` - (Optional) Provides information used to select Amazon Machine Images (AMIs) for EC2 instances in the compute environment. If Ec2Configuration isn't specified, the default is ECS_AL2. This parameter isn't applicable to jobs that are running on Fargate resources, and shouldn't be specified.
* `ec2KeyPair` - (Optional) The EC2 key pair that is used for instances launched in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `imageId` - (Optional) The Amazon Machine Image (AMI) ID used for instances launched in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified. (Deprecated, use [`ec2Configuration`](#ec2_configuration) `imageIdOverride` instead)
* `instanceRole` - (Optional) The Amazon ECS instance role applied to Amazon EC2 instances in a compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `instanceType` - (Optional) A list of instance types that may be launched. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `launchTemplate` - (Optional) The launch template to use for your compute resources. See details below. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `maxVcpus` - (Required) The maximum number of EC2 vCPUs that an environment can reach.
* `minVcpus` - (Optional) The minimum number of EC2 vCPUs that an environment should maintain. For `EC2` or `SPOT` compute environments, if the parameter is not explicitly defined, a `0` default value will be set. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `placementGroup` - (Optional) The Amazon EC2 placement group to associate with your compute resources.
* `securityGroupIds` - (Optional) A list of EC2 security group that are associated with instances launched in the compute environment. This parameter is required for Fargate compute environments.
* `spotIamFleetRole` - (Optional) The Amazon Resource Name (ARN) of the Amazon EC2 Spot Fleet IAM role applied to a SPOT compute environment. This parameter is required for SPOT compute environments. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `subnets` - (Required) A list of VPC subnets into which the compute resources are launched.
* `tags` - (Optional) Key-value pair tags to be applied to resources that are launched in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `type` - (Required) The type of compute environment. Valid items are `EC2`, `SPOT`, `FARGATE` or `FARGATE_SPOT`.

### ec2_configuration

`ec2Configuration` supports the following:

* `imageIdOverride` - (Optional) The AMI ID used for instances launched in the compute environment that match the image type. This setting overrides the `imageId` argument in the [`computeResources`](#compute_resources) block.
* `imageType` - (Optional) The image type to match with the instance type to select an AMI. If the `imageIdOverride` parameter isn't specified, then a recent [Amazon ECS-optimized Amazon Linux 2 AMI](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html#al2ami) (`ECS_AL2`) is used.

### launch_template

`launchTemplate` supports the following:

* `launchTemplateId` - (Optional) ID of the launch template. You must specify either the launch template ID or launch template name in the request, but not both.
* `launchTemplateName` - (Optional) Name of the launch template.
* `version` - (Optional) The version number of the launch template. Default: The default version of the launch template.

### eks_configuration

`eksConfiguration` supports the following:

* `eksClusterArn` - (Required) The Amazon Resource Name (ARN) of the Amazon EKS cluster.
* `kubernetesNamespace` - (Required) The namespace of the Amazon EKS cluster. AWS Batch manages pods in this namespace.

### update_policy

`updatePolicy` supports the following:

* `jobExecutionTimeoutMinutes` - (Required) Specifies the job timeout (in minutes) when the compute environment infrastructure is updated.
* `terminateJobsOnUpdate` - (Required) Specifies whether jobs are automatically terminated when the computer environment infrastructure is updated.

## Attribute Reference

This resource exports the following attributes in addition to the arguments above:

* `arn` - The Amazon Resource Name (ARN) of the compute environment.
* `ecsClusterArn` - The Amazon Resource Name (ARN) of the underlying Amazon ECS cluster used by the compute environment.
* `status` - The current status of the compute environment (for example, CREATING or VALID).
* `statusReason` - A short, human-readable string to provide additional details about the current status of the compute environment.
* `tagsAll` - A map of tags assigned to the resource, including those inherited from the provider [`defaultTags` configuration block](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#default_tags-configuration-block).

## Import

In Terraform v1.5.0 and later, use an [`import` block](https://developer.hashicorp.com/terraform/language/import) to import AWS Batch compute using the `computeEnvironmentName`. For example:

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { BatchComputeEnvironment } from "./.gen/providers/aws/batch-compute-environment";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    BatchComputeEnvironment.generateConfigForImport(this, "sample", "sample");
  }
}

```

Using `terraform import`, import AWS Batch compute using the `computeEnvironmentName`. For example:

```console
% terraform import aws_batch_compute_environment.sample sample
```

[1]: http://docs.aws.amazon.com/batch/latest/userguide/what-is-batch.html
[2]: http://docs.aws.amazon.com/batch/latest/userguide/compute_environments.html
[3]: http://docs.aws.amazon.com/batch/latest/userguide/troubleshooting.html

<!-- cache-key: cdktf-0.20.1 input-a4d2fad96b051bf90d8da55fdec7bad58af8e8716e155068f8033f1e7ecde7a0 -->