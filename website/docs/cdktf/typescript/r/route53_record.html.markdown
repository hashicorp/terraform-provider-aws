---
subcategory: "Route 53"
layout: "aws"
page_title: "AWS: aws_route53_record"
description: |-
  Provides a Route53 record resource.
---


<!-- Please do not edit this file, it is generated. -->
# Resource: aws_route53_record

Provides a Route53 record resource.

## Example Usage

### Simple routing policy

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { Route53Record } from "./.gen/providers/aws/route53-record";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new Route53Record(this, "www", {
      name: "www.example.com",
      records: [lb.publicIp],
      ttl: 300,
      type: "A",
      zoneId: primary.zoneId,
    });
  }
}

```

### Weighted routing policy

Other routing policies are configured similarly. See [Amazon Route 53 Developer Guide](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html) for details.

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { Route53Record } from "./.gen/providers/aws/route53-record";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new Route53Record(this, "www-dev", {
      name: "www",
      records: ["dev.example.com"],
      setIdentifier: "dev",
      ttl: 5,
      type: "CNAME",
      weightedRoutingPolicy: {
        weight: 10,
      },
      zoneId: primary.zoneId,
    });
    new Route53Record(this, "www-live", {
      name: "www",
      records: ["live.example.com"],
      setIdentifier: "live",
      ttl: 5,
      type: "CNAME",
      weightedRoutingPolicy: {
        weight: 90,
      },
      zoneId: primary.zoneId,
    });
  }
}

```

### Geoproximity routing policy

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { Route53Record } from "./.gen/providers/aws/route53-record";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new Route53Record(this, "www", {
      geoproximityRoutingPolicy: {
        coordinates: [
          {
            latitude: "49.22",
            longitude: "-74.01",
          },
        ],
      },
      name: "www.example.com",
      records: ["dev.example.com"],
      setIdentifier: "dev",
      ttl: 300,
      type: "CNAME",
      zoneId: primary.zoneId,
    });
  }
}

```

### Alias record

See [related part of Amazon Route 53 Developer Guide](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-choosing-alias-non-alias.html)
to understand differences between alias and non-alias records.

TTL for all alias records is [60 seconds](https://aws.amazon.com/route53/faqs/#dns_failover_do_i_need_to_adjust),
you cannot change this, therefore `ttl` has to be omitted in alias records.

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { Elb } from "./.gen/providers/aws/elb";
import { Route53Record } from "./.gen/providers/aws/route53-record";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const main = new Elb(this, "main", {
      availabilityZones: ["us-east-1c"],
      listener: [
        {
          instancePort: 80,
          instanceProtocol: "http",
          lbPort: 80,
          lbProtocol: "http",
        },
      ],
      name: "foobar-terraform-elb",
    });
    new Route53Record(this, "www", {
      alias: {
        evaluateTargetHealth: true,
        name: main.dnsName,
        zoneId: main.zoneId,
      },
      name: "example.com",
      type: "A",
      zoneId: primary.zoneId,
    });
  }
}

```

### NS and SOA Record Management

When creating Route 53 zones, the `NS` and `SOA` records for the zone are automatically created. Enabling the `allowOverwrite` argument will allow managing these records in a single Terraform run without the requirement for `terraform import`.

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Fn, Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { Route53Record } from "./.gen/providers/aws/route53-record";
import { Route53Zone } from "./.gen/providers/aws/route53-zone";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const example = new Route53Zone(this, "example", {
      name: "test.example.com",
    });
    const awsRoute53RecordExample = new Route53Record(this, "example_1", {
      allowOverwrite: true,
      name: "test.example.com",
      records: [
        Token.asString(Fn.lookupNested(example.nameServers, ["0"])),
        Token.asString(Fn.lookupNested(example.nameServers, ["1"])),
        Token.asString(Fn.lookupNested(example.nameServers, ["2"])),
        Token.asString(Fn.lookupNested(example.nameServers, ["3"])),
      ],
      ttl: 172800,
      type: "NS",
      zoneId: example.zoneId,
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsRoute53RecordExample.overrideLogicalId("example");
  }
}

```

## Argument Reference

This resource supports the following arguments:

* `zoneId` - (Required) The ID of the hosted zone to contain this record.
* `name` - (Required) The name of the record.
* `type` - (Required) The record type. Valid values are `A`, `AAAA`, `CAA`, `CNAME`, `DS`, `MX`, `NAPTR`, `NS`, `PTR`, `SOA`, `SPF`, `SRV` and `TXT`.
* `ttl` - (Required for non-alias records) The TTL of the record.
* `records` - (Required for non-alias records) A string list of records. To specify a single record value longer than 255 characters such as a TXT record for DKIM, add `\"\"` inside the Terraform configuration string (e.g., `"first255characters\"\"morecharacters"`).
* `setIdentifier` - (Optional) Unique identifier to differentiate records with routing policies from one another. Required if using `cidrRoutingPolicy`, `failoverRoutingPolicy`, `geolocationRoutingPolicy`,`geoproximityRoutingPolicy`, `latencyRoutingPolicy`, `multivalueAnswerRoutingPolicy`, or `weightedRoutingPolicy`.
* `healthCheckId` - (Optional) The health check the record should be associated with.
* `alias` - (Optional) An alias block. Conflicts with `ttl` & `records`.
  [Documented below](#alias).
* `cidrRoutingPolicy` - (Optional) A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. [Documented below](#cidr-routing-policy).
* `failoverRoutingPolicy` - (Optional) A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. [Documented below](#failover-routing-policy).
* `geolocationRoutingPolicy` - (Optional) A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. [Documented below](#geolocation-routing-policy).
* `geoproximityRoutingPolicy` - (Optional) A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. [Documented below](#geoproximity-routing-policy).
* `latencyRoutingPolicy` - (Optional) A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. [Documented below](#latency-routing-policy).
* `multivalueAnswerRoutingPolicy` - (Optional) Set to `true` to indicate a multivalue answer routing policy. Conflicts with any other routing policy.
* `weightedRoutingPolicy` - (Optional) A block indicating a weighted routing policy. Conflicts with any other routing policy. [Documented below](#weighted-routing-policy).
* `allowOverwrite` - (Optional) Allow creation of this record in Terraform to overwrite an existing record, if any. This does not affect the ability to update the record in Terraform and does not prevent other resources within Terraform or manual Route 53 changes outside Terraform from overwriting this record. `false` by default. This configuration is not recommended for most environments.

Exactly one of `records` or `alias` must be specified: this determines whether it's an alias record.

### Alias

Alias records support the following:

* `name` - (Required) DNS domain name for a CloudFront distribution, S3 bucket, ELB, or another resource record set in this hosted zone.
* `zoneId` - (Required) Hosted zone ID for a CloudFront distribution, S3 bucket, ELB, or Route 53 hosted zone. See [`resource_elb.zone_id`](/docs/providers/aws/r/elb.html#zone_id) for example.
* `evaluateTargetHealth` - (Required) Set to `true` if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see [related part of documentation](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values.html#rrsets-values-alias-evaluate-target-health).

### CIDR Routing Policy

CIDR routing policies support the following:

* `collectionId` - (Required) The CIDR collection ID. See the [`aws_route53_cidr_collection` resource](route53_cidr_collection.html) for more details.
* `locationName` - (Required) The CIDR collection location name. See the [`aws_route53_cidr_location` resource](route53_cidr_location.html) for more details. A `locationName` with an asterisk `"*"` can be used to create a default CIDR record. `collectionId` is still required for default record.

### Failover Routing Policy

Failover routing policies support the following:

* `type` - (Required) `PRIMARY` or `SECONDARY`. A `PRIMARY` record will be served if its healthcheck is passing, otherwise the `SECONDARY` will be served. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-configuring-options.html#dns-failover-failover-rrsets

### Geolocation Routing Policy

Geolocation routing policies support the following:

* `continent` - A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either `continent` or `country` must be specified.
* `country` - A two-character country code or `*` to indicate a default resource record set.
* `subdivision` - (Optional) A subdivision code for a country.

### GeoproximityRouting Policy

Geoproximity routing policies support the following:

* `awsRegion` - A AWS region where the resource is present.
* `bias` - Route more traffic or less traffic to the resource by specifying a value ranges between -90 to 90. See https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html for bias details.
* `coordinates` - Specify `latitude` and `longitude` for routing traffic to non-AWS resources.
* `localZoneGroup` - A AWS local zone group where the resource is present. See https://docs.aws.amazon.com/local-zones/latest/ug/available-local-zones.html for local zone group list.

### Latency Routing Policy

Latency routing policies support the following:

* `region` - (Required) An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency

### Weighted Routing Policy

Weighted routing policies support the following:

* `weight` - (Required) A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.

## Attribute Reference

This resource exports the following attributes in addition to the arguments above:

* `name` - The name of the record.
* `fqdn` - [FQDN](https://en.wikipedia.org/wiki/Fully_qualified_domain_name) built using the zone domain and `name`.

## Import

In Terraform v1.5.0 and later, use an [`import` block](https://developer.hashicorp.com/terraform/language/import) to import Route53 Records using the ID of the record, record name, record type, and set identifier. For example:

Using the ID of the record, which is the zone identifier, record name, and record type, separated by underscores (`_`):

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { Route53Record } from "./.gen/providers/aws/route53-record";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    Route53Record.generateConfigForImport(
      this,
      "myrecord",
      "Z4KAPRWWNC7JR_dev.example.com_NS"
    );
  }
}

```

If the record also contains a set identifier, append it:

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { Route53Record } from "./.gen/providers/aws/route53-record";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    Route53Record.generateConfigForImport(
      this,
      "myrecord",
      "Z4KAPRWWNC7JR_dev.example.com_NS_dev"
    );
  }
}

```

If the record name is the empty string, it can be omitted:

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { Route53Record } from "./.gen/providers/aws/route53-record";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    Route53Record.generateConfigForImport(
      this,
      "myrecord",
      "Z4KAPRWWNC7JR__NS"
    );
  }
}

```

**Using `terraform import` to import** Route53 Records using the ID of the record, record name, record type, and set identifier. For example:

Using the ID of the record, which is the zone identifier, record name, and record type, separated by underscores (`_`):

```console
% terraform import aws_route53_record.myrecord Z4KAPRWWNC7JR_dev_NS
```

If the record also contains a set identifier, append it:

```console
% terraform import aws_route53_record.myrecord Z4KAPRWWNC7JR_dev_NS_dev
```

<!-- cache-key: cdktf-0.20.8 input-fc20fd130ce2202c5a6719f9387f559be6d934c048b4f1e4916641814f3f2574 -->