---
subcategory: "Lambda"
layout: "aws"
page_title: "AWS: aws_lambda_function"
description: |-
  Manages an AWS Lambda Function.
---


<!-- Please do not edit this file, it is generated. -->
# Resource: aws_lambda_function

Manages an AWS Lambda Function. Use this resource to create serverless functions that run code in response to events without provisioning or managing servers.

For information about Lambda and how to use it, see [What is AWS Lambda?](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html). For a detailed example of setting up Lambda and API Gateway, see [Serverless Applications with AWS Lambda and API Gateway](https://learn.hashicorp.com/terraform/aws/lambda-api-gateway).

~> **Note:** Due to [AWS Lambda improved VPC networking changes that began deploying in September 2019](https://aws.amazon.com/blogs/compute/announcing-improved-vpc-networking-for-aws-lambda-functions/), EC2 subnets and security groups associated with Lambda Functions can take up to 45 minutes to successfully delete. Terraform AWS Provider version 2.31.0 and later automatically handles this increased timeout, however prior versions require setting the customizable deletion timeouts of those Terraform resources to 45 minutes (`delete = "45m"`). AWS and HashiCorp are working together to reduce the amount of time required for resource deletion and updates can be tracked in this [GitHub issue](https://github.com/hashicorp/terraform-provider-aws/issues/10329).

~> **Note:** If you get a `KMSAccessDeniedException: Lambda was unable to decrypt the environment variables because KMS access was denied` error when invoking an `aws_lambda_function` with environment variables, the IAM role associated with the function may have been deleted and recreated after the function was created. You can fix the problem two ways: 1) updating the function's role to another role and then updating it back again to the recreated role, or 2) by using Terraform to `taint` the function and `apply` your configuration again to recreate the function. (When you create a function, Lambda grants permissions on the KMS key to the function's IAM role. If the IAM role is recreated, the grant is no longer valid. Changing the function's role or recreating the function causes Lambda to update the grant.)

-> **Tip:** To give an external source (like an EventBridge Rule, SNS, or S3) permission to access the Lambda function, use the [`aws_lambda_permission`](lambda_permission.html) resource. See [Lambda Permission Model](https://docs.aws.amazon.com/lambda/latest/dg/intro-permission-model.html) for more details. On the other hand, the `role` argument of this resource is the function's execution role for identity and access to AWS services and resources.

## Example Usage

### Basic Function with Node.js

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { DataArchiveFile } from "./.gen/providers/archive/data-archive-file";
import { DataAwsIamPolicyDocument } from "./.gen/providers/aws/data-aws-iam-policy-document";
import { IamRole } from "./.gen/providers/aws/iam-role";
import { LambdaFunction } from "./.gen/providers/aws/lambda-function";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    /*The following providers are missing schema information and might need manual adjustments to synthesize correctly: archive.
    For a more precise conversion please use the --provider flag in convert.*/
    const example = new DataArchiveFile(this, "example", {
      output_path: "${path.module}/lambda/function.zip",
      source_file: "${path.module}/lambda/index.js",
      type: "zip",
    });
    const assumeRole = new DataAwsIamPolicyDocument(this, "assume_role", {
      statement: [
        {
          actions: ["sts:AssumeRole"],
          effect: "Allow",
          principals: [
            {
              identifiers: ["lambda.amazonaws.com"],
              type: "Service",
            },
          ],
        },
      ],
    });
    const awsIamRoleExample = new IamRole(this, "example_2", {
      assumeRolePolicy: Token.asString(assumeRole.json),
      name: "lambda_execution_role",
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamRoleExample.overrideLogicalId("example");
    const awsLambdaFunctionExample = new LambdaFunction(this, "example_3", {
      environment: {
        variables: {
          ENVIRONMENT: "production",
          LOG_LEVEL: "info",
        },
      },
      filename: Token.asString(example.outputPath),
      functionName: "example_lambda_function",
      handler: "index.handler",
      role: Token.asString(awsIamRoleExample.arn),
      runtime: "nodejs20.x",
      sourceCodeHash: Token.asString(example.outputBase64Sha256),
      tags: {
        Application: "example",
        Environment: "production",
      },
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsLambdaFunctionExample.overrideLogicalId("example");
  }
}

```

### Container Image Function

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { LambdaFunction } from "./.gen/providers/aws/lambda-function";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new LambdaFunction(this, "example", {
      architectures: ["arm64"],
      functionName: "example_container_function",
      imageConfig: {
        command: ["app.handler"],
        entryPoint: ["/lambda-entrypoint.sh"],
      },
      imageUri: "${" + awsEcrRepositoryExample.repositoryUrl + "}:latest",
      memorySize: 512,
      packageType: "Image",
      role: Token.asString(awsIamRoleExample.arn),
      timeout: 30,
    });
  }
}

```

### Function with Lambda Layers

~> **Note:** The `aws_lambda_layer_version` attribute values for `arn` and `layerArn` were swapped in version 2.0.0 of the Terraform AWS Provider. For version 2.x, use `arn` references.

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { LambdaFunction } from "./.gen/providers/aws/lambda-function";
import { LambdaLayerVersion } from "./.gen/providers/aws/lambda-layer-version";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const example = new LambdaLayerVersion(this, "example", {
      compatibleArchitectures: ["x86_64", "arm64"],
      compatibleRuntimes: ["nodejs20.x", "python3.12"],
      description: "Common dependencies for Lambda functions",
      filename: "layer.zip",
      layerName: "example_dependencies_layer",
    });
    const awsLambdaFunctionExample = new LambdaFunction(this, "example_1", {
      filename: "function.zip",
      functionName: "example_layered_function",
      handler: "index.handler",
      layers: [example.arn],
      role: Token.asString(awsIamRoleExample.arn),
      runtime: "nodejs20.x",
      tracingConfig: {
        mode: "Active",
      },
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsLambdaFunctionExample.overrideLogicalId("example");
  }
}

```

### VPC Function with Enhanced Networking

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { LambdaFunction } from "./.gen/providers/aws/lambda-function";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new LambdaFunction(this, "example", {
      ephemeralStorage: {
        size: 5120,
      },
      filename: "function.zip",
      functionName: "example_vpc_function",
      handler: "app.handler",
      memorySize: 1024,
      role: Token.asString(awsIamRoleExample.arn),
      runtime: "python3.12",
      snapStart: {
        applyOn: "PublishedVersions",
      },
      timeout: 30,
      vpcConfig: {
        ipv6AllowedForDualStack: true,
        securityGroupIds: [exampleLambda.id],
        subnetIds: [examplePrivate1.id, examplePrivate2.id],
      },
    });
  }
}

```

### Function with EFS Integration

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import {
  VariableType,
  TerraformVariable,
  Fn,
  Token,
  TerraformCount,
  TerraformStack,
} from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { EfsAccessPoint } from "./.gen/providers/aws/efs-access-point";
import { EfsFileSystem } from "./.gen/providers/aws/efs-file-system";
import { EfsMountTarget } from "./.gen/providers/aws/efs-mount-target";
import { LambdaFunction } from "./.gen/providers/aws/lambda-function";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    /*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
    You can read more about this at https://cdk.tf/variables*/
    const subnetIds = new TerraformVariable(this, "subnet_ids", {
      default: ["subnet-12345678", "subnet-87654321"],
      description: "List of subnet IDs for EFS mount targets",
      type: VariableType.list(VariableType.STRING),
    });
    const example = new EfsFileSystem(this, "example", {
      encrypted: true,
      tags: {
        Name: "lambda-efs",
      },
    });
    /*In most cases loops should be handled in the programming language context and 
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const exampleCount = TerraformCount.of(
      Token.asNumber(Fn.lengthOf(subnetIds.value))
    );
    const awsEfsMountTargetExample = new EfsMountTarget(this, "example_2", {
      fileSystemId: example.id,
      securityGroups: [efs.id],
      subnetId: Token.asString(
        Fn.lookupNested(subnetIds.value, [exampleCount.index])
      ),
      count: exampleCount,
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsEfsMountTargetExample.overrideLogicalId("example");
    const awsEfsAccessPointExample = new EfsAccessPoint(this, "example_3", {
      fileSystemId: example.id,
      posixUser: {
        gid: 1000,
        uid: 1000,
      },
      rootDirectory: {
        creationInfo: {
          ownerGid: 1000,
          ownerUid: 1000,
          permissions: "755",
        },
        path: "/lambda",
      },
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsEfsAccessPointExample.overrideLogicalId("example");
    const awsLambdaFunctionExample = new LambdaFunction(this, "example_4", {
      dependsOn: [awsEfsMountTargetExample],
      fileSystemConfig: {
        arn: Token.asString(awsEfsAccessPointExample.arn),
        localMountPath: "/mnt/data",
      },
      filename: "function.zip",
      functionName: "example_efs_function",
      handler: "index.handler",
      role: Token.asString(awsIamRoleExample.arn),
      runtime: "nodejs20.x",
      vpcConfig: {
        securityGroupIds: [lambda.id],
        subnetIds: subnetIds.listValue,
      },
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsLambdaFunctionExample.overrideLogicalId("example");
  }
}

```

### Function with Advanced Logging

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { CloudwatchLogGroup } from "./.gen/providers/aws/cloudwatch-log-group";
import { LambdaFunction } from "./.gen/providers/aws/lambda-function";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const example = new CloudwatchLogGroup(this, "example", {
      name: "/aws/lambda/example_function",
      retentionInDays: 14,
      tags: {
        Application: "example",
        Environment: "production",
      },
    });
    const awsLambdaFunctionExample = new LambdaFunction(this, "example_1", {
      dependsOn: [example],
      filename: "function.zip",
      functionName: "example_function",
      handler: "index.handler",
      loggingConfig: {
        applicationLogLevel: "INFO",
        logFormat: "JSON",
        systemLogLevel: "WARN",
      },
      role: Token.asString(awsIamRoleExample.arn),
      runtime: "nodejs20.x",
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsLambdaFunctionExample.overrideLogicalId("example");
  }
}

```

### Function with logging to S3 or Data Firehose

#### Required Resources

* An S3 bucket or Data Firehose delivery stream to store the logs.
* A CloudWatch Log Group with:

    * `log_group_class = "DELIVERY"`
    * A subscription filter whose `destinationArn` points to the S3 bucket or the Data Firehose delivery stream.

* IAM roles:

    * Assumed by the `logs.amazonaws.com` service to deliver logs to the S3 bucket or Data Firehose delivery stream.
    * Assumed by the `lambda.amazonaws.com` service to send logs to CloudWatch Logs

* A Lambda function:

    * In the `loggingConfiguration`, specify the name of the Log Group created above using the `logGroup` field
    * No special configuration is required to use S3 or Firehose as the log destination

For more details, see [Sending Lambda function logs to Amazon S3](https://docs.aws.amazon.com/lambda/latest/dg/logging-with-s3.html).

#### Example: Exporting Lambda Logs to S3 Bucket

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { CloudwatchLogGroup } from "./.gen/providers/aws/cloudwatch-log-group";
import { CloudwatchLogSubscriptionFilter } from "./.gen/providers/aws/cloudwatch-log-subscription-filter";
import { DataAwsIamPolicyDocument } from "./.gen/providers/aws/data-aws-iam-policy-document";
import { IamRole } from "./.gen/providers/aws/iam-role";
import { IamRolePolicy } from "./.gen/providers/aws/iam-role-policy";
import { LambdaFunction } from "./.gen/providers/aws/lambda-function";
import { S3Bucket } from "./.gen/providers/aws/s3-bucket";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const lambdaFunctionName = "lambda-log-export-example";
    const exportVar = new CloudwatchLogGroup(this, "export", {
      logGroupClass: "DELIVERY",
      name: "/aws/lambda/${" + lambdaFunctionName + "}",
    });
    new LambdaFunction(this, "log_export", {
      dependsOn: [exportVar],
      filename: "function.zip",
      functionName: lambdaFunctionName,
      handler: "index.lambda_handler",
      loggingConfig: {
        logFormat: "Text",
        logGroup: exportVar.name,
      },
      role: example.arn,
      runtime: "python3.13",
    });
    const lambdaLogExport = new S3Bucket(this, "lambda_log_export", {
      bucket: "${" + lambdaFunctionName + "}-bucket",
    });
    const dataAwsIamPolicyDocumentLambdaLogExport =
      new DataAwsIamPolicyDocument(this, "lambda_log_export_3", {
        statement: [
          {
            actions: ["s3:PutObject"],
            effect: "Allow",
            resources: ["${" + lambdaLogExport.arn + "}/*"],
          },
        ],
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    dataAwsIamPolicyDocumentLambdaLogExport.overrideLogicalId(
      "lambda_log_export"
    );
    const logsAssumeRole = new DataAwsIamPolicyDocument(
      this,
      "logs_assume_role",
      {
        statement: [
          {
            actions: ["sts:AssumeRole"],
            effect: "Allow",
            principals: [
              {
                identifiers: ["logs.amazonaws.com"],
                type: "Service",
              },
            ],
          },
        ],
      }
    );
    const logsLogExport = new IamRole(this, "logs_log_export", {
      assumeRolePolicy: Token.asString(logsAssumeRole.json),
      name: "${" + lambdaFunctionName + "}-lambda-log-export-role",
    });
    const awsIamRolePolicyLambdaLogExport = new IamRolePolicy(
      this,
      "lambda_log_export_6",
      {
        policy: Token.asString(dataAwsIamPolicyDocumentLambdaLogExport.json),
        role: logsLogExport.name,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamRolePolicyLambdaLogExport.overrideLogicalId("lambda_log_export");
    const awsCloudwatchLogSubscriptionFilterLambdaLogExport =
      new CloudwatchLogSubscriptionFilter(this, "lambda_log_export_7", {
        destinationArn: lambdaLogExport.arn,
        filterPattern: "",
        logGroupName: exportVar.name,
        name: "${" + lambdaFunctionName + "}-filter",
        roleArn: logsLogExport.arn,
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsCloudwatchLogSubscriptionFilterLambdaLogExport.overrideLogicalId(
      "lambda_log_export"
    );
  }
}

```

### Function with Error Handling

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { LambdaFunction } from "./.gen/providers/aws/lambda-function";
import { LambdaFunctionEventInvokeConfig } from "./.gen/providers/aws/lambda-function-event-invoke-config";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const example = new LambdaFunction(this, "example", {
      deadLetterConfig: {
        targetArn: dlq.arn,
      },
      filename: "function.zip",
      functionName: "example_function",
      handler: "index.handler",
      role: Token.asString(awsIamRoleExample.arn),
      runtime: "nodejs20.x",
    });
    const awsLambdaFunctionEventInvokeConfigExample =
      new LambdaFunctionEventInvokeConfig(this, "example_1", {
        destinationConfig: {
          onFailure: {
            destination: dlq.arn,
          },
          onSuccess: {
            destination: success.arn,
          },
        },
        functionName: example.functionName,
        maximumEventAgeInSeconds: 60,
        maximumRetryAttempts: 2,
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsLambdaFunctionEventInvokeConfigExample.overrideLogicalId("example");
  }
}

```

### CloudWatch Logging and Permissions

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import {
  VariableType,
  TerraformVariable,
  Fn,
  Token,
  TerraformStack,
} from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { CloudwatchLogGroup } from "./.gen/providers/aws/cloudwatch-log-group";
import { IamPolicy } from "./.gen/providers/aws/iam-policy";
import { IamRole } from "./.gen/providers/aws/iam-role";
import { IamRolePolicyAttachment } from "./.gen/providers/aws/iam-role-policy-attachment";
import { LambdaFunction } from "./.gen/providers/aws/lambda-function";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    /*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
    You can read more about this at https://cdk.tf/variables*/
    const functionName = new TerraformVariable(this, "function_name", {
      default: "example_function",
      description: "Name of the Lambda function",
      type: VariableType.STRING,
    });
    const example = new CloudwatchLogGroup(this, "example", {
      name: "/aws/lambda/${" + functionName.value + "}",
      retentionInDays: 14,
      tags: {
        Environment: "production",
        Function: functionName.stringValue,
      },
    });
    const lambdaLogging = new IamPolicy(this, "lambda_logging", {
      description: "IAM policy for logging from Lambda",
      name: "lambda_logging",
      path: "/",
      policy: Token.asString(
        Fn.jsonencode({
          Statement: [
            {
              Action: [
                "logs:CreateLogGroup",
                "logs:CreateLogStream",
                "logs:PutLogEvents",
              ],
              Effect: "Allow",
              Resource: ["arn:aws:logs:*:*:*"],
            },
          ],
          Version: "2012-10-17",
        })
      ),
    });
    const awsIamRoleExample = new IamRole(this, "example_3", {
      assumeRolePolicy: Token.asString(
        Fn.jsonencode({
          Statement: [
            {
              Action: "sts:AssumeRole",
              Effect: "Allow",
              Principal: {
                Service: "lambda.amazonaws.com",
              },
            },
          ],
          Version: "2012-10-17",
        })
      ),
      name: "lambda_execution_role",
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamRoleExample.overrideLogicalId("example");
    const lambdaLogs = new IamRolePolicyAttachment(this, "lambda_logs", {
      policyArn: lambdaLogging.arn,
      role: Token.asString(awsIamRoleExample.name),
    });
    const awsLambdaFunctionExample = new LambdaFunction(this, "example_5", {
      dependsOn: [lambdaLogs, example],
      filename: "function.zip",
      functionName: functionName.stringValue,
      handler: "index.handler",
      loggingConfig: {
        applicationLogLevel: "INFO",
        logFormat: "JSON",
        systemLogLevel: "WARN",
      },
      role: Token.asString(awsIamRoleExample.arn),
      runtime: "nodejs20.x",
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsLambdaFunctionExample.overrideLogicalId("example");
  }
}

```

## Specifying the Deployment Package

AWS Lambda expects source code to be provided as a deployment package whose structure varies depending on which `runtime` is in use. See [Runtimes](https://docs.aws.amazon.com/lambda/latest/dg/API_CreateFunction.html#SSS-CreateFunction-request-Runtime) for the valid values of `runtime`. The expected structure of the deployment package can be found in [the AWS Lambda documentation for each runtime](https://docs.aws.amazon.com/lambda/latest/dg/deployment-package-v2.html).

Once you have created your deployment package you can specify it either directly as a local file (using the `filename` argument) or indirectly via Amazon S3 (using the `s3Bucket`, `s3Key` and `s3ObjectVersion` arguments). When providing the deployment package via S3 it may be useful to use [the `aws_s3_object` resource](s3_object.html) to upload it.

For larger deployment packages it is recommended by Amazon to upload via S3, since the S3 API has better support for uploading large files efficiently.

## Argument Reference

The following arguments are required:

* `functionName` - (Required) Unique name for your Lambda Function.
* `role` - (Required) ARN of the function's execution role. The role provides the function's identity and access to AWS services and resources.

The following arguments are optional:

* `architectures` - (Optional) Instruction set architecture for your Lambda function. Valid values are `["x86_64"]` and `["arm64"]`. Default is `["x86_64"]`. Removing this attribute, function's architecture stays the same.
* `codeSigningConfigArn` - (Optional) ARN of a code-signing configuration to enable code signing for this function.
* `deadLetterConfig` - (Optional) Configuration block for dead letter queue. [See below](#dead_letter_config-configuration-block).
* `description` - (Optional) Description of what your Lambda Function does.
* `environment` - (Optional) Configuration block for environment variables. [See below](#environment-configuration-block).
* `ephemeralStorage` - (Optional) Amount of ephemeral storage (`/tmp`) to allocate for the Lambda Function. [See below](#ephemeral_storage-configuration-block).
* `fileSystemConfig` - (Optional) Configuration block for EFS file system. [See below](#file_system_config-configuration-block).
* `filename` - (Optional) Path to the function's deployment package within the local filesystem. Conflicts with `imageUri` and `s3Bucket`. One of `filename`, `imageUri`, or `s3Bucket` must be specified.
* `handler` - (Optional) Function entry point in your code. Required if `packageType` is `Zip`.
* `imageConfig` - (Optional) Container image configuration values. [See below](#image_config-configuration-block).
* `imageUri` - (Optional) ECR image URI containing the function's deployment package. Conflicts with `filename` and `s3Bucket`. One of `filename`, `imageUri`, or `s3Bucket` must be specified.
* `kmsKeyArn` - (Optional) ARN of the AWS Key Management Service key used to encrypt environment variables. If not provided when environment variables are in use, AWS Lambda uses a default service key. If provided when environment variables are not in use, the AWS Lambda API does not save this configuration.
* `layers` - (Optional) List of Lambda Layer Version ARNs (maximum of 5) to attach to your Lambda Function.
* `loggingConfig` - (Optional) Configuration block for advanced logging settings. [See below](#logging_config-configuration-block).
* `memorySize` - (Optional) Amount of memory in MB your Lambda Function can use at runtime. Valid value between 128 MB to 10,240 MB (10 GB), in 1 MB increments. Defaults to 128.
* `packageType` - (Optional) Lambda deployment package type. Valid values are `Zip` and `Image`. Defaults to `Zip`.
* `publish` - (Optional) Whether to publish creation/change as new Lambda Function Version. Defaults to `false`.
* `region` - (Optional) Region where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the [provider configuration](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#aws-configuration-reference).
* `replaceSecurityGroupsOnDestroy` - (Optional) Whether to replace the security groups on the function's VPC configuration prior to destruction. Default is `false`.
* `replacementSecurityGroupIds` - (Optional) List of security group IDs to assign to the function's VPC configuration prior to destruction. Required if `replaceSecurityGroupsOnDestroy` is `true`.
* `reservedConcurrentExecutions` - (Optional) Amount of reserved concurrent executions for this lambda function. A value of `0` disables lambda from being triggered and `-1` removes any concurrency limitations. Defaults to Unreserved Concurrency Limits `-1`.
* `runtime` - (Optional) Identifier of the function's runtime. Required if `packageType` is `Zip`. See [Runtimes](https://docs.aws.amazon.com/lambda/latest/dg/API_CreateFunction.html#SSS-CreateFunction-request-Runtime) for valid values.
* `s3Bucket` - (Optional) S3 bucket location containing the function's deployment package. Conflicts with `filename` and `imageUri`. One of `filename`, `imageUri`, or `s3Bucket` must be specified.
* `s3Key` - (Optional) S3 key of an object containing the function's deployment package. Required if `s3Bucket` is set.
* `s3ObjectVersion` - (Optional) Object version containing the function's deployment package. Conflicts with `filename` and `imageUri`.
* `skipDestroy` - (Optional) Whether to retain the old version of a previously deployed Lambda Layer. Default is `false`.
* `snapStart` - (Optional) Configuration block for snap start settings. [See below](#snap_start-configuration-block).
* `sourceCodeHash` - (Optional) Base64-encoded SHA256 hash of the package file. Used to trigger updates when source code changes.
* `sourceKmsKeyArn` - (Optional) ARN of the AWS Key Management Service key used to encrypt the function's `.zip` deployment package. Conflicts with `imageUri`.
* `tags` - (Optional) Key-value map of tags for the Lambda function. If configured with a provider [`defaultTags` configuration block](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#default_tags-configuration-block) present, tags with matching keys will overwrite those defined at the provider-level.
* `timeout` - (Optional) Amount of time your Lambda Function has to run in seconds. Defaults to 3. Valid between 1 and 900.
* `tracingConfig` - (Optional) Configuration block for X-Ray tracing. [See below](#tracing_config-configuration-block).
* `vpcConfig` - (Optional) Configuration block for VPC. [See below](#vpc_config-configuration-block).

### dead_letter_config Configuration Block

* `targetArn` - (Required) ARN of an SNS topic or SQS queue to notify when an invocation fails.

### environment Configuration Block

* `variables` - (Optional) Map of environment variables available to your Lambda function during execution.

### ephemeral_storage Configuration Block

* `size` - (Required) Amount of ephemeral storage (`/tmp`) in MB. Valid between 512 MB and 10,240 MB (10 GB).

### file_system_config Configuration Block

* `arn` - (Required) ARN of the Amazon EFS Access Point.
* `localMountPath` - (Required) Path where the function can access the file system. Must start with `/mnt/`.

### image_config Configuration Block

* `command` - (Optional) Parameters to pass to the container image.
* `entryPoint` - (Optional) Entry point to your application.
* `workingDirectory` - (Optional) Working directory for the container image.

### logging_config Configuration Block

* `applicationLogLevel` - (Optional) Detail level of application logs. Valid values: `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`, `FATAL`.
* `logFormat` - (Required) Log format. Valid values: `Text`, `JSON`.
* `logGroup` - (Optional) CloudWatch log group where logs are sent.
* `systemLogLevel` - (Optional) Detail level of Lambda platform logs. Valid values: `DEBUG`, `INFO`, `WARN`.

### snap_start Configuration Block

* `applyOn` - (Required) When to apply snap start optimization. Valid value: `PublishedVersions`.

### tracing_config Configuration Block

* `mode` - (Required) X-Ray tracing mode. Valid values: `Active`, `PassThrough`.

### vpc_config Configuration Block

~> **NOTE:** If `subnetIds`, `securityGroupIds` and `ipv6AllowedForDualStack` are empty then `vpcConfig` is considered to be empty or unset.

* `ipv6AllowedForDualStack` - (Optional) Whether to allow outbound IPv6 traffic on VPC functions connected to dual-stack subnets. Default: `false`.
* `securityGroupIds` - (Required) List of security group IDs associated with the Lambda function.
* `subnetIds` - (Required) List of subnet IDs associated with the Lambda function.

## Attribute Reference

This resource exports the following attributes in addition to the arguments above:

* `arn` - ARN identifying your Lambda Function.
* `codeSha256` - Base64-encoded representation of raw SHA-256 sum of the zip file.
* `invokeArn` - ARN to be used for invoking Lambda Function from API Gateway - to be used in [`aws_api_gateway_integration`](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/api_gateway_integration)'s `uri`.
* `lastModified` - Date this resource was last modified.
* `qualifiedArn` - ARN identifying your Lambda Function Version (if versioning is enabled via `publish = true`).
* `qualifiedInvokeArn` - Qualified ARN (ARN with lambda version number) to be used for invoking Lambda Function from API Gateway - to be used in [`aws_api_gateway_integration`](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/api_gateway_integration)'s `uri`.
* `signingJobArn` - ARN of the signing job.
* `signingProfileVersionArn` - ARN of the signing profile version.
* `snap_start.optimization_status` - Optimization status of the snap start configuration. Valid values are `On` and `Off`.
* `sourceCodeSize` - Size in bytes of the function .zip file.
* `tagsAll` - Map of tags assigned to the resource, including those inherited from the provider [`defaultTags` configuration block](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#default_tags-configuration-block).
* `version` - Latest published version of your Lambda Function.
* `vpc_config.vpc_id` - ID of the VPC.

## Timeouts

[Configuration options](https://developer.hashicorp.com/terraform/language/resources/syntax#operation-timeouts):

* `create` - (Default `10m`)
* `update` - (Default `10m`)
* `delete` - (Default `10m`)

## Import

In Terraform v1.12.0 and later, the [`import` block](https://developer.hashicorp.com/terraform/language/import) can be used with the `identity` attribute. For example:

```terraform
import {
  to = aws_lambda_function.example
  identity = {
    function_name = "example"
  }
}

resource "aws_lambda_function" "example" {
  ### Configuration omitted for brevity ###
}
```

### Identity Schema

#### Required

* `functionName` (String) Name of the Lambda function.

#### Optional

* `accountId` (String) AWS Account where this resource is managed.
* `region` (String) Region where this resource is managed.

In Terraform v1.5.0 and later, use an [`import` block](https://developer.hashicorp.com/terraform/language/import) to import Lambda Functions using the `functionName`. For example:

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { LambdaFunction } from "./.gen/providers/aws/lambda-function";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    LambdaFunction.generateConfigForImport(this, "example", "example");
  }
}

```

Using `terraform import`, import Lambda Functions using the `functionName`. For example:

```console
% terraform import aws_lambda_function.example example
```

<!-- cache-key: cdktf-0.20.8 input-f7ee325f11c59546f1e13ab7fc593a4066f6bcb79cf2c09f42d3b474f1cf35fd -->