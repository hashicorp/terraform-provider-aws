---
subcategory: "AppSync"
layout: "aws"
page_title: "AWS: aws_appsync_resolver"
description: |-
  Provides an AppSync Resolver.
---


<!-- Please do not edit this file, it is generated. -->
# Resource: aws_appsync_resolver

Provides an AppSync Resolver.

## Example Usage

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { AppsyncDatasource } from "./.gen/providers/aws/appsync-datasource";
import { AppsyncGraphqlApi } from "./.gen/providers/aws/appsync-graphql-api";
import { AppsyncResolver } from "./.gen/providers/aws/appsync-resolver";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const test = new AppsyncGraphqlApi(this, "test", {
      authenticationType: "API_KEY",
      name: "tf-example",
      schema:
        "type Mutation {\n\tputPost(id: ID!, title: String!): Post\n}\n\ntype Post {\n\tid: ID!\n\ttitle: String!\n}\n\ntype Query {\n\tsinglePost(id: ID!): Post\n}\n\nschema {\n\tquery: Query\n\tmutation: Mutation\n}\n\n",
    });
    new AppsyncResolver(this, "Mutation_pipelineTest", {
      apiId: test.id,
      field: "pipelineTest",
      kind: "PIPELINE",
      pipelineConfig: {
        functions: [test1.functionId, test2.functionId, test3.functionId],
      },
      requestTemplate: "{}",
      responseTemplate: "$util.toJson($ctx.result)",
      type: "Mutation",
    });
    const awsAppsyncDatasourceTest = new AppsyncDatasource(this, "test_2", {
      apiId: test.id,
      httpConfig: {
        endpoint: "http://example.com",
      },
      name: "tf_example",
      type: "HTTP",
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsAppsyncDatasourceTest.overrideLogicalId("test");
    const awsAppsyncResolverTest = new AppsyncResolver(this, "test_3", {
      apiId: test.id,
      cachingConfig: {
        cachingKeys: ["$context.identity.sub", "$context.arguments.id"],
        ttl: 60,
      },
      dataSource: Token.asString(awsAppsyncDatasourceTest.name),
      field: "singlePost",
      requestTemplate:
        '{\n    "version": "2018-05-29",\n    "method": "GET",\n    "resourcePath": "/",\n    "params":{\n        "headers": $utils.http.copyheaders($ctx.request.headers)\n    }\n}\n\n',
      responseTemplate:
        "#if($ctx.result.statusCode == 200)\n    $ctx.result.body\n#else\n    $utils.appendError($ctx.result.body, $ctx.result.statusCode)\n#end\n\n",
      type: "Query",
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsAppsyncResolverTest.overrideLogicalId("test");
  }
}

```

## Example Usage JS

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Fn, Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { AppsyncResolver } from "./.gen/providers/aws/appsync-resolver";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new AppsyncResolver(this, "example", {
      apiId: test.id,
      code: Token.asString(Fn.file("some-code-dir")),
      field: "pipelineTest",
      kind: "PIPELINE",
      pipelineConfig: {
        functions: [Token.asString(awsAppsyncFunctionTest.functionId)],
      },
      runtime: {
        name: "APPSYNC_JS",
        runtimeVersion: "1.0.0",
      },
      type: "Query",
    });
  }
}

```

## Argument Reference

This resource supports the following arguments:

* `apiId` - (Required) API ID for the GraphQL API.
* `code` - (Optional) The function code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
* `type` - (Required) Type name from the schema defined in the GraphQL API.
* `field` - (Required) Field name from the schema defined in the GraphQL API.
* `requestTemplate` - (Optional) Request mapping template for UNIT resolver or 'before mapping template' for PIPELINE resolver. Required for non-Lambda resolvers.
* `responseTemplate` - (Optional) Response mapping template for UNIT resolver or 'after mapping template' for PIPELINE resolver. Required for non-Lambda resolvers.
* `dataSource` - (Optional) Data source name.
* `maxBatchSize` - (Optional) Maximum batching size for a resolver. Valid values are between `0` and `2000`.
* `kind`  - (Optional) Resolver type. Valid values are `UNIT` and `PIPELINE`.
* `syncConfig` - (Optional) Describes a Sync configuration for a resolver. See [Sync Config](#sync-config).
* `pipelineConfig` - (Optional) The caching configuration for the resolver. See [Pipeline Config](#pipeline-config).
* `cachingConfig` - (Optional) The Caching Config. See [Caching Config](#caching-config).
* `runtime` - (Optional) Describes a runtime used by an AWS AppSync pipeline resolver or AWS AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified. See [Runtime](#runtime).

### Caching Config

* `cachingKeys` - (Optional) The caching keys for a resolver that has caching activated. Valid values are entries from the $context.arguments, $context.source, and $context.identity maps.
* `ttl` - (Optional) The TTL in seconds for a resolver that has caching activated. Valid values are between `1` and `3600` seconds.

### Pipeline Config

* `functions` - (Optional) A list of Function objects.

### Sync Config

* `conflictDetection` - (Optional) Conflict Detection strategy to use. Valid values are `NONE` and `VERSION`.
* `conflictHandler` - (Optional) Conflict Resolution strategy to perform in the event of a conflict. Valid values are `NONE`, `OPTIMISTIC_CONCURRENCY`, `AUTOMERGE`, and `LAMBDA`.
* `lambdaConflictHandlerConfig` - (Optional) Lambda Conflict Handler Config when configuring `LAMBDA` as the Conflict Handler. See [Lambda Conflict Handler Config](#lambda-conflict-handler-config).

#### Lambda Conflict Handler Config

* `lambdaConflictHandlerArn` - (Optional) ARN for the Lambda function to use as the Conflict Handler.

### Runtime

* `name` - (Optional) The name of the runtime to use. Currently, the only allowed value is `APPSYNC_JS`.
* `runtimeVersion` - (Optional) The version of the runtime to use. Currently, the only allowed version is `1.0.0`.

## Attribute Reference

This resource exports the following attributes in addition to the arguments above:

* `arn` - ARN

## Import

In Terraform v1.5.0 and later, use an [`import` block](https://developer.hashicorp.com/terraform/language/import) to import `aws_appsync_resolver` using the `apiId`, a hyphen, `type`, a hypen and `field`. For example:

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { AppsyncResolver } from "./.gen/providers/aws/appsync-resolver";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    AppsyncResolver.generateConfigForImport(
      this,
      "example",
      "abcdef123456-exampleType-exampleField"
    );
  }
}

```

Using `terraform import`, import `aws_appsync_resolver` using the `apiId`, a hyphen, `type`, a hypen and `field`. For example:

```console
% terraform import aws_appsync_resolver.example abcdef123456-exampleType-exampleField
```

<!-- cache-key: cdktf-0.20.1 input-c52e7e65e799b6104f6c311a148eb1f52433b7035e764e94e6ade1153f6ef6e4 -->