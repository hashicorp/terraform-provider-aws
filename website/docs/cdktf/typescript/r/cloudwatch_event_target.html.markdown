---
subcategory: "EventBridge"
layout: "aws"
page_title: "AWS: aws_cloudwatch_event_target"
description: |-
  Provides an EventBridge Target resource.
---


<!-- Please do not edit this file, it is generated. -->
# Resource: aws_cloudwatch_event_target

Provides an EventBridge Target resource.

~> **Note:** EventBridge was formerly known as CloudWatch Events. The functionality is identical.

## Example Usage

### Kinesis Usage

```terraform
resource "aws_cloudwatch_event_target" "yada" {
  target_id = "Yada"
  rule      = aws_cloudwatch_event_rule.console.name
  arn       = aws_kinesis_stream.test_stream.arn

  run_command_targets {
    key    = "tag:Name"
    values = ["FooBar"]
  }

  run_command_targets {
    key    = "InstanceIds"
    values = ["i-162058cd308bffec2"]
  }
}

resource "aws_cloudwatch_event_rule" "console" {
  name        = "capture-ec2-scaling-events"
  description = "Capture all EC2 scaling events"

  event_pattern = jsonencode({
    source = [
      "aws.autoscaling"
    ]

    detail-type = [
      "EC2 Instance Launch Successful",
      "EC2 Instance Terminate Successful",
      "EC2 Instance Launch Unsuccessful",
      "EC2 Instance Terminate Unsuccessful"
    ]
  })
}

resource "aws_kinesis_stream" "test_stream" {
  name        = "terraform-kinesis-test"
  shard_count = 1
}
```

### SSM Document Usage

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Fn, Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { CloudwatchEventRule } from "./.gen/providers/aws/cloudwatch-event-rule";
import { CloudwatchEventTarget } from "./.gen/providers/aws/cloudwatch-event-target";
import { DataAwsIamPolicyDocument } from "./.gen/providers/aws/data-aws-iam-policy-document";
import { IamPolicy } from "./.gen/providers/aws/iam-policy";
import { IamRole } from "./.gen/providers/aws/iam-role";
import { IamRolePolicyAttachment } from "./.gen/providers/aws/iam-role-policy-attachment";
import { SsmDocument } from "./.gen/providers/aws/ssm-document";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const stopInstances = new CloudwatchEventRule(this, "stop_instances", {
      description: "Stop instances nightly",
      name: "StopInstance",
      scheduleExpression: "cron(0 0 * * ? *)",
    });
    const stopInstance = new SsmDocument(this, "stop_instance", {
      content: Token.asString(
        Fn.jsonencode({
          description: "Stop an instance",
          parameters: {},
          runtimeConfig: {
            "aws:runShellScript": {
              properties: [
                {
                  id: "0.aws:runShellScript",
                  runCommand: ["halt"],
                },
              ],
            },
          },
          schemaVersion: "1.2",
        })
      ),
      documentType: "Command",
      name: "stop_instance",
    });
    const ssmLifecycle = new DataAwsIamPolicyDocument(this, "ssm_lifecycle", {
      statement: [
        {
          actions: ["ssm:SendCommand"],
          condition: [
            {
              test: "StringEquals",
              values: ["*"],
              variable: "ec2:ResourceTag/Terminate",
            },
          ],
          effect: "Allow",
          resources: ["arn:aws:ec2:eu-west-1:1234567890:instance/*"],
        },
        {
          actions: ["ssm:SendCommand"],
          effect: "Allow",
          resources: [stopInstance.arn],
        },
      ],
    });
    const ssmLifecycleTrust = new DataAwsIamPolicyDocument(
      this,
      "ssm_lifecycle_trust",
      {
        statement: [
          {
            actions: ["sts:AssumeRole"],
            principals: [
              {
                identifiers: ["events.amazonaws.com"],
                type: "Service",
              },
            ],
          },
        ],
      }
    );
    const awsIamPolicySsmLifecycle = new IamPolicy(this, "ssm_lifecycle_4", {
      name: "SSMLifecycle",
      policy: Token.asString(ssmLifecycle.json),
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamPolicySsmLifecycle.overrideLogicalId("ssm_lifecycle");
    const awsIamRoleSsmLifecycle = new IamRole(this, "ssm_lifecycle_5", {
      assumeRolePolicy: Token.asString(ssmLifecycleTrust.json),
      name: "SSMLifecycle",
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamRoleSsmLifecycle.overrideLogicalId("ssm_lifecycle");
    const awsIamRolePolicyAttachmentSsmLifecycle = new IamRolePolicyAttachment(
      this,
      "ssm_lifecycle_6",
      {
        policyArn: Token.asString(awsIamPolicySsmLifecycle.arn),
        role: Token.asString(awsIamRoleSsmLifecycle.name),
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamRolePolicyAttachmentSsmLifecycle.overrideLogicalId("ssm_lifecycle");
    const awsCloudwatchEventTargetStopInstances = new CloudwatchEventTarget(
      this,
      "stop_instances_7",
      {
        arn: stopInstance.arn,
        roleArn: Token.asString(awsIamRoleSsmLifecycle.arn),
        rule: stopInstances.name,
        runCommandTargets: [
          {
            key: "tag:Terminate",
            values: ["midnight"],
          },
        ],
        targetId: "StopInstance",
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsCloudwatchEventTargetStopInstances.overrideLogicalId("stop_instances");
  }
}

```

### RunCommand Usage

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { CloudwatchEventRule } from "./.gen/providers/aws/cloudwatch-event-rule";
import { CloudwatchEventTarget } from "./.gen/providers/aws/cloudwatch-event-target";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const stopInstances = new CloudwatchEventRule(this, "stop_instances", {
      description: "Stop instances nightly",
      name: "StopInstance",
      scheduleExpression: "cron(0 0 * * ? *)",
    });
    const awsCloudwatchEventTargetStopInstances = new CloudwatchEventTarget(
      this,
      "stop_instances_1",
      {
        arn:
          "arn:aws:ssm:${" + awsRegion.value + "}::document/AWS-RunShellScript",
        input: '{\\"commands\\":[\\"halt\\"]}',
        roleArn: ssmLifecycle.arn,
        rule: stopInstances.name,
        runCommandTargets: [
          {
            key: "tag:Terminate",
            values: ["midnight"],
          },
        ],
        targetId: "StopInstance",
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsCloudwatchEventTargetStopInstances.overrideLogicalId("stop_instances");
  }
}

```

### ECS Run Task with Role and Task Override Usage

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Fn, Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { CloudwatchEventTarget } from "./.gen/providers/aws/cloudwatch-event-target";
import { DataAwsIamPolicyDocument } from "./.gen/providers/aws/data-aws-iam-policy-document";
import { IamRole } from "./.gen/providers/aws/iam-role";
import { IamRolePolicy } from "./.gen/providers/aws/iam-role-policy";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const assumeRole = new DataAwsIamPolicyDocument(this, "assume_role", {
      statement: [
        {
          actions: ["sts:AssumeRole"],
          effect: "Allow",
          principals: [
            {
              identifiers: ["events.amazonaws.com"],
              type: "Service",
            },
          ],
        },
      ],
    });
    const ecsEventsRunTaskWithAnyRole = new DataAwsIamPolicyDocument(
      this,
      "ecs_events_run_task_with_any_role",
      {
        statement: [
          {
            actions: ["iam:PassRole"],
            effect: "Allow",
            resources: ["*"],
          },
          {
            actions: ["ecs:RunTask"],
            effect: "Allow",
            resources: [
              Token.asString(Fn.replace(taskName.arn, "/:\\\\d+$/", ":*")),
            ],
          },
        ],
      }
    );
    const ecsEvents = new IamRole(this, "ecs_events", {
      assumeRolePolicy: Token.asString(assumeRole.json),
      name: "ecs_events",
    });
    const awsIamRolePolicyEcsEventsRunTaskWithAnyRole = new IamRolePolicy(
      this,
      "ecs_events_run_task_with_any_role_3",
      {
        name: "ecs_events_run_task_with_any_role",
        policy: Token.asString(ecsEventsRunTaskWithAnyRole.json),
        role: ecsEvents.id,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamRolePolicyEcsEventsRunTaskWithAnyRole.overrideLogicalId(
      "ecs_events_run_task_with_any_role"
    );
    new CloudwatchEventTarget(this, "ecs_scheduled_task", {
      arn: clusterName.arn,
      ecsTarget: {
        taskCount: 1,
        taskDefinitionArn: taskName.arn,
      },
      input: Token.asString(
        Fn.jsonencode({
          containerOverrides: [
            {
              command: ["bin/console", "scheduled-task"],
              name: "name-of-container-to-override",
            },
          ],
        })
      ),
      roleArn: ecsEvents.arn,
      rule: everyHour.name,
      targetId: "run-scheduled-task-every-hour",
    });
  }
}

```

### API Gateway target

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { ApiGatewayDeployment } from "./.gen/providers/aws/api-gateway-deployment";
import { ApiGatewayStage } from "./.gen/providers/aws/api-gateway-stage";
import { CloudwatchEventRule } from "./.gen/providers/aws/cloudwatch-event-rule";
import { CloudwatchEventTarget } from "./.gen/providers/aws/cloudwatch-event-target";
interface MyConfig {
  stageName: any;
}
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string, config: MyConfig) {
    super(scope, name);
    const example = new ApiGatewayDeployment(this, "example", {
      restApiId: Token.asString(awsApiGatewayRestApiExample.id),
    });
    const awsApiGatewayStageExample = new ApiGatewayStage(this, "example_1", {
      deploymentId: example.id,
      restApiId: Token.asString(awsApiGatewayRestApiExample.id),
      stageName: config.stageName,
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsApiGatewayStageExample.overrideLogicalId("example");
    const awsCloudwatchEventRuleExample = new CloudwatchEventRule(
      this,
      "example_2",
      {}
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsCloudwatchEventRuleExample.overrideLogicalId("example");
    const awsCloudwatchEventTargetExample = new CloudwatchEventTarget(
      this,
      "example_3",
      {
        arn: "${" + awsApiGatewayStageExample.executionArn + "}/GET",
        httpTarget: {
          headerParameters: {
            Env: "Test",
          },
          queryStringParameters: {
            Body: "$.detail.body",
          },
        },
        rule: Token.asString(awsCloudwatchEventRuleExample.id),
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsCloudwatchEventTargetExample.overrideLogicalId("example");
  }
}

```

### Cross-Account Event Bus target

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { CloudwatchEventRule } from "./.gen/providers/aws/cloudwatch-event-rule";
import { CloudwatchEventTarget } from "./.gen/providers/aws/cloudwatch-event-target";
import { DataAwsIamPolicyDocument } from "./.gen/providers/aws/data-aws-iam-policy-document";
import { IamPolicy } from "./.gen/providers/aws/iam-policy";
import { IamRole } from "./.gen/providers/aws/iam-role";
import { IamRolePolicyAttachment } from "./.gen/providers/aws/iam-role-policy-attachment";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const stopInstances = new CloudwatchEventRule(this, "stop_instances", {
      description: "Stop instances nightly",
      name: "StopInstance",
      scheduleExpression: "cron(0 0 * * ? *)",
    });
    const assumeRole = new DataAwsIamPolicyDocument(this, "assume_role", {
      statement: [
        {
          actions: ["sts:AssumeRole"],
          effect: "Allow",
          principals: [
            {
              identifiers: ["events.amazonaws.com"],
              type: "Service",
            },
          ],
        },
      ],
    });
    const eventBusInvokeRemoteEventBus = new DataAwsIamPolicyDocument(
      this,
      "event_bus_invoke_remote_event_bus",
      {
        statement: [
          {
            actions: ["events:PutEvents"],
            effect: "Allow",
            resources: [
              "arn:aws:events:eu-west-1:1234567890:event-bus/My-Event-Bus",
            ],
          },
        ],
      }
    );
    const awsIamPolicyEventBusInvokeRemoteEventBus = new IamPolicy(
      this,
      "event_bus_invoke_remote_event_bus_3",
      {
        name: "event_bus_invoke_remote_event_bus",
        policy: Token.asString(eventBusInvokeRemoteEventBus.json),
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamPolicyEventBusInvokeRemoteEventBus.overrideLogicalId(
      "event_bus_invoke_remote_event_bus"
    );
    const awsIamRoleEventBusInvokeRemoteEventBus = new IamRole(
      this,
      "event_bus_invoke_remote_event_bus_4",
      {
        assumeRolePolicy: Token.asString(assumeRole.json),
        name: "event-bus-invoke-remote-event-bus",
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamRoleEventBusInvokeRemoteEventBus.overrideLogicalId(
      "event_bus_invoke_remote_event_bus"
    );
    const awsIamRolePolicyAttachmentEventBusInvokeRemoteEventBus =
      new IamRolePolicyAttachment(this, "event_bus_invoke_remote_event_bus_5", {
        policyArn: Token.asString(awsIamPolicyEventBusInvokeRemoteEventBus.arn),
        role: Token.asString(awsIamRoleEventBusInvokeRemoteEventBus.name),
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamRolePolicyAttachmentEventBusInvokeRemoteEventBus.overrideLogicalId(
      "event_bus_invoke_remote_event_bus"
    );
    const awsCloudwatchEventTargetStopInstances = new CloudwatchEventTarget(
      this,
      "stop_instances_6",
      {
        arn: "arn:aws:events:eu-west-1:1234567890:event-bus/My-Event-Bus",
        roleArn: Token.asString(awsIamRoleEventBusInvokeRemoteEventBus.arn),
        rule: stopInstances.name,
        targetId: "StopInstance",
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsCloudwatchEventTargetStopInstances.overrideLogicalId("stop_instances");
  }
}

```

### Input Transformer Usage - JSON Object

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { CloudwatchEventRule } from "./.gen/providers/aws/cloudwatch-event-rule";
import { CloudwatchEventTarget } from "./.gen/providers/aws/cloudwatch-event-target";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const example = new CloudwatchEventRule(this, "example", {});
    const awsCloudwatchEventTargetExample = new CloudwatchEventTarget(
      this,
      "example_1",
      {
        arn: Token.asString(awsLambdaFunctionExample.arn),
        inputTransformer: {
          inputPaths: {
            instance: "$.detail.instance",
            status: "$.detail.status",
          },
          inputTemplate:
            '{\n  "instance_id": <instance>,\n  "instance_status": <status>\n}\n\n',
        },
        rule: example.id,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsCloudwatchEventTargetExample.overrideLogicalId("example");
  }
}

```

### Input Transformer Usage - Simple String

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { CloudwatchEventRule } from "./.gen/providers/aws/cloudwatch-event-rule";
import { CloudwatchEventTarget } from "./.gen/providers/aws/cloudwatch-event-target";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const example = new CloudwatchEventRule(this, "example", {});
    const awsCloudwatchEventTargetExample = new CloudwatchEventTarget(
      this,
      "example_1",
      {
        arn: Token.asString(awsLambdaFunctionExample.arn),
        inputTransformer: {
          inputPaths: {
            instance: "$.detail.instance",
            status: "$.detail.status",
          },
          inputTemplate: '\\"<instance> is in state <status>\\"',
        },
        rule: example.id,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsCloudwatchEventTargetExample.overrideLogicalId("example");
  }
}

```

### Cloudwatch Log Group Usage

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Fn, Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { CloudwatchEventRule } from "./.gen/providers/aws/cloudwatch-event-rule";
import { CloudwatchEventTarget } from "./.gen/providers/aws/cloudwatch-event-target";
import { CloudwatchLogGroup } from "./.gen/providers/aws/cloudwatch-log-group";
import { CloudwatchLogResourcePolicy } from "./.gen/providers/aws/cloudwatch-log-resource-policy";
import { DataAwsIamPolicyDocument } from "./.gen/providers/aws/data-aws-iam-policy-document";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const example = new CloudwatchEventRule(this, "example", {
      description: "GuardDuty Findings",
      eventPattern: Token.asString(
        Fn.jsonencode({
          source: ["aws.guardduty"],
        })
      ),
      name: "guard-duty_event_rule",
      tags: {
        Environment: "example",
      },
    });
    const awsCloudwatchLogGroupExample = new CloudwatchLogGroup(
      this,
      "example_1",
      {
        name: "/aws/events/guardduty/logs",
        retentionInDays: 1,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsCloudwatchLogGroupExample.overrideLogicalId("example");
    const exampleLogPolicy = new DataAwsIamPolicyDocument(
      this,
      "example_log_policy",
      {
        statement: [
          {
            actions: ["logs:CreateLogStream"],
            effect: "Allow",
            principals: [
              {
                identifiers: [
                  "events.amazonaws.com",
                  "delivery.logs.amazonaws.com",
                ],
                type: "Service",
              },
            ],
            resources: ["${" + awsCloudwatchLogGroupExample.arn + "}:*"],
          },
          {
            actions: ["logs:PutLogEvents"],
            condition: [
              {
                test: "ArnEquals",
                values: [example.arn],
                variable: "aws:SourceArn",
              },
            ],
            effect: "Allow",
            principals: [
              {
                identifiers: [
                  "events.amazonaws.com",
                  "delivery.logs.amazonaws.com",
                ],
                type: "Service",
              },
            ],
            resources: ["${" + awsCloudwatchLogGroupExample.arn + "}:*:*"],
          },
        ],
      }
    );
    const awsCloudwatchEventTargetExample = new CloudwatchEventTarget(
      this,
      "example_3",
      {
        arn: Token.asString(awsCloudwatchLogGroupExample.arn),
        rule: example.name,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsCloudwatchEventTargetExample.overrideLogicalId("example");
    const awsCloudwatchLogResourcePolicyExample =
      new CloudwatchLogResourcePolicy(this, "example_4", {
        policyDocument: Token.asString(exampleLogPolicy.json),
        policyName: "guardduty-log-publishing-policy",
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsCloudwatchLogResourcePolicyExample.overrideLogicalId("example");
  }
}

```

## Argument Reference

-> **Note:** In order to be able to have your AWS Lambda function or
   SNS topic invoked by an EventBridge rule, you must set up the right permissions
   using [`aws_lambda_permission`](/docs/providers/aws/r/lambda_permission.html)
   or [`aws_sns_topic_policy`](/docs/providers/aws/r/sns_topic_policy.html).
   More info [here](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-use-resource-based.html).

The following arguments are required:

* `arn` - (Required) The Amazon Resource Name (ARN) of the target.
* `rule` - (Required) The name of the rule you want to add targets to.

The following arguments are optional:

* `batchTarget` - (Optional) Parameters used when you are using the rule to invoke an Amazon Batch Job. Documented below. A maximum of 1 are allowed.
* `deadLetterConfig` - (Optional)  Parameters used when you are providing a dead letter config. Documented below. A maximum of 1 are allowed.
* `ecsTarget` - (Optional) Parameters used when you are using the rule to invoke Amazon ECS Task. Documented below. A maximum of 1 are allowed.
* `eventBusName` - (Optional) The name or ARN of the event bus to associate with the rule.
  If you omit this, the `default` event bus is used.
* `forceDestroy` - (Optional) Used to delete managed rules created by AWS. Defaults to `false`.
* `httpTarget` - (Optional) Parameters used when you are using the rule to invoke an API Gateway REST endpoint. Documented below. A maximum of 1 is allowed.
* `input` - (Optional) Valid JSON text passed to the target. Conflicts with `inputPath` and `inputTransformer`.
* `inputPath` - (Optional) The value of the [JSONPath](http://goessner.net/articles/JsonPath/) that is used for extracting part of the matched event when passing it to the target. Conflicts with `input` and `inputTransformer`.
* `inputTransformer` - (Optional) Parameters used when you are providing a custom input to a target based on certain event data. Conflicts with `input` and `inputPath`.
* `kinesisTarget` - (Optional) Parameters used when you are using the rule to invoke an Amazon Kinesis Stream. Documented below. A maximum of 1 are allowed.
* `roleArn` - (Optional) The Amazon Resource Name (ARN) of the IAM role to be used for this target when the rule is triggered. Required if `ecsTarget` is used or target in `arn` is EC2 instance, Kinesis data stream, Step Functions state machine, or Event Bus in different account or region.
* `runCommandTargets` - (Optional) Parameters used when you are using the rule to invoke Amazon EC2 Run Command. Documented below. A maximum of 5 are allowed.
* `redshiftTarget` - (Optional) Parameters used when you are using the rule to invoke an Amazon Redshift Statement. Documented below. A maximum of 1 are allowed.
* `retryPolicy` - (Optional)  Parameters used when you are providing retry policies. Documented below. A maximum of 1 are allowed.
* `sagemakerPipelineTarget` - (Optional) Parameters used when you are using the rule to invoke an Amazon SageMaker Pipeline. Documented below. A maximum of 1 are allowed.
* `sqsTarget` - (Optional) Parameters used when you are using the rule to invoke an Amazon SQS Queue. Documented below. A maximum of 1 are allowed.
* `targetId` - (Optional) The unique target assignment ID. If missing, will generate a random, unique id.

### batch_target

* `jobDefinition` - (Required) The ARN or name of the job definition to use if the event target is an AWS Batch job. This job definition must already exist.
* `jobName` - (Required) The name to use for this execution of the job, if the target is an AWS Batch job.
* `arraySize` - (Optional) The size of the array, if this is an array batch job. Valid values are integers between 2 and 10,000.
* `jobAttempts` - (Optional) The number of times to attempt to retry, if the job fails. Valid values are 1 to 10.

### capacity_provider_strategy

* `capacityProvider` - (Required) Short name of the capacity provider.
* `weight` - (Required) The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.
* `base` - (Optional) The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Defaults to `0`.

### dead_letter_config

* `arn` - (Optional) - ARN of the SQS queue specified as the target for the dead-letter queue.

### ecs_target

* `taskDefinitionArn` - (Required) The ARN of the task definition to use if the event target is an Amazon ECS cluster.
* `capacityProviderStrategy` - (Optional) The capacity provider strategy to use for the task. If a `capacityProviderStrategy` specified, the `launchType` parameter must be omitted. If no `capacityProviderStrategy` or `launchType` is specified, the default capacity provider strategy for the cluster is used. Can be one or more. See below.
* `enableEcsManagedTags` - (Optional) Specifies whether to enable Amazon ECS managed tags for the task.
* `enableExecuteCommand` - (Optional) Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.
* `group` - (Optional) Specifies an ECS task group for the task. The maximum length is 255 characters.
* `launchType` - (Optional) Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. Valid values include: `EC2`, `EXTERNAL`, or `FARGATE`.
* `networkConfiguration` - (Optional) Use this if the ECS task uses the awsvpc network mode. This specifies the VPC subnets and security groups associated with the task, and whether a public IP address is to be used. Required if `launchType` is `FARGATE` because the awsvpc mode is required for Fargate tasks.
* `orderedPlacementStrategy` - (Optional) An array of placement strategy objects to use for the task. You can specify a maximum of five strategy rules per task.
* `placementConstraint` - (Optional) An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime). See Below.
* `platformVersion` - (Optional) Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as `1.1.0`. This is used only if LaunchType is FARGATE. For more information about valid platform versions, see [AWS Fargate Platform Versions](http://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).
* `propagateTags` - (Optional) Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. The only valid value is: `TASK_DEFINITION`.
* `taskCount` - (Optional) The number of tasks to create based on the TaskDefinition. Defaults to `1`.
* `tags` - (Optional) A map of tags to assign to ecs resources.

### http_target

* `headerParameters` - (Optional) Enables you to specify HTTP headers to add to the request.
* `pathParameterValues` - (Optional) The list of values that correspond sequentially to any path variables in your endpoint ARN (for example `arn:aws:execute-api:us-east-1:123456:myapi/*/POST/pets/*`).
* `queryStringParameters` - (Optional) Represents keys/values of query string parameters that are appended to the invoked endpoint.

### input_transformer

* `inputTemplate` - (Required) Template to customize data sent to the target. Must be valid JSON. To send a string value, the string value must include double quotes. Values must be escaped for both JSON and Terraform, e.g., `"\"Your string goes here.\\nA new line.\""`
* `inputPaths` - (Optional) Key value pairs specified in the form of JSONPath (for example, time = $.time)
    * You can have as many as 100 key-value pairs.
    * You must use JSON dot notation, not bracket notation.
    * The keys can't start with "AWS".

### kinesis_target

* `partitionKeyPath` - (Optional) The JSON path to be extracted from the event and used as the partition key.

### network_configuration

* `subnets` - (Required) The subnets associated with the task or service.
* `securityGroups` - (Optional) The security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
* `assignPublicIp` - (Optional) Assign a public IP address to the ENI (Fargate launch type only). Valid values are `true` or `false`. Defaults to `false`.

For more information, see [Task Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html)

### ordered_placement_strategy

* `type` - (Required) Type of placement strategy. The only valid values at this time are `binpack`, `random` and `spread`.
* `field` - (Optional) The field to apply the placement strategy against. For the `spread` placement strategy, valid values are `instanceId` (or `host`, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as `attribute:ecs.availability-zone`. For the `binpack` placement strategy, valid values are `cpu` and `memory`. For the `random` placement strategy, this field is not used. For more information, see [Amazon ECS task placement strategies](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html).

### placement_constraint

* `type` - (Required) Type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`.
* `expression` -  (Optional) Cluster Query Language expression to apply to the constraint. Does not need to be specified for the `distinctInstance` type. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).

### redshift_target

* `database` - (Required) The name of the database.
* `dbUser` - (Optional) The database user name.
* `secretsManagerArn` - (Optional) The name or ARN of the secret that enables access to the database.
* `sql` - (Optional) The SQL statement text to run.
* `statementName` - (Optional) The name of the SQL statement.
* `withEvent` - (Optional) Indicates whether to send an event back to EventBridge after the SQL statement runs.

### retry_policy

* `maximumEventAgeInSeconds` - (Optional) The age in seconds to continue to make retry attempts.
* `maximumRetryAttempts` - (Optional) maximum number of retry attempts to make before the request fails

### run_command_targets

* `key` - (Required) Can be either `tag:tag-key` or `InstanceIds`.
* `values` - (Required) If Key is `tag:tag-key`, Values is a list of tag values. If Key is `InstanceIds`, Values is a list of Amazon EC2 instance IDs.

### sqs_target

* `messageGroupId` - (Optional) The FIFO message group ID to use as the target.

### sagemaker_pipeline_target

* `pipelineParameterList` - (Optional) List of Parameter names and values for SageMaker Model Building Pipeline execution.

#### pipeline_parameter_list

* `name` - (Required) Name of parameter to start execution of a SageMaker Model Building Pipeline.
* `value` - (Required) Value of parameter to start execution of a SageMaker Model Building Pipeline.

## Attribute Reference

This resource exports no additional attributes.

## Import

In Terraform v1.5.0 and later, use an [`import` block](https://developer.hashicorp.com/terraform/language/import) to import EventBridge Targets using `event_bus_name/rule-name/target-id` (if you omit `eventBusName`, the `default` event bus will be used). For example:

 ```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { CloudwatchEventTarget } from "./.gen/providers/aws/cloudwatch-event-target";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    CloudwatchEventTarget.generateConfigForImport(
      this,
      "testEventTarget",
      "rule-name/target-id"
    );
  }
}

```

Using `terraform import`, import EventBridge Targets using `event_bus_name/rule-name/target-id` (if you omit `eventBusName`, the `default` event bus will be used). For example:

 ```console
% terraform import aws_cloudwatch_event_target.test-event-target rule-name/target-id
```

<!-- cache-key: cdktf-0.20.1 input-acca2e4c4d9e32765a5d4c3e255d1c924fd19735df376f9c30498d94ce55e01e -->