---
subcategory: "Auto Scaling Plans"
layout: "aws"
page_title: "AWS: aws_autoscalingplans_scaling_plan"
description: |-
  Manages an AWS Auto Scaling scaling plan.
---


<!-- Please do not edit this file, it is generated. -->
# Resource: aws_autoscalingplans_scaling_plan

Manages an AWS Auto Scaling scaling plan.
More information can be found in the [AWS Auto Scaling User Guide](https://docs.aws.amazon.com/autoscaling/plans/userguide/what-is-aws-auto-scaling.html).

~> **NOTE:** The AWS Auto Scaling service uses an AWS IAM service-linked role to manage predictive scaling of Amazon EC2 Auto Scaling groups. The service attempts to automatically create this role the first time a scaling plan with predictive scaling enabled is created.
An [`aws_iam_service_linked_role`](/docs/providers/aws/r/iam_service_linked_role.html) resource can be used to manually manage this role.
See the [AWS documentation](https://docs.aws.amazon.com/autoscaling/plans/userguide/aws-auto-scaling-service-linked-roles.html#create-service-linked-role-manual) for more details.

## Example Usage

### Basic Dynamic Scaling

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Fn, Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { AutoscalingGroup } from "./.gen/providers/aws/autoscaling-group";
import { AutoscalingplansScalingPlan } from "./.gen/providers/aws/autoscalingplans-scaling-plan";
import { DataAwsAvailabilityZones } from "./.gen/providers/aws/data-aws-availability-zones";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const available = new DataAwsAvailabilityZones(this, "available", {});
    const example = new AutoscalingGroup(this, "example", {
      availabilityZones: [
        Token.asString(Fn.lookupNested(available.names, ["0"])),
      ],
      launchConfiguration: Token.asString(awsLaunchConfigurationExample.name),
      maxSize: 3,
      minSize: 0,
      namePrefix: "example",
      tags: [
        {
          key: "application",
          propagate_at_launch: true,
          value: "example",
        },
      ],
    });
    const awsAutoscalingplansScalingPlanExample =
      new AutoscalingplansScalingPlan(this, "example_2", {
        applicationSource: {
          tagFilter: [
            {
              key: "application",
              values: ["example"],
            },
          ],
        },
        name: "example-dynamic-cost-optimization",
        scalingInstruction: [
          {
            maxCapacity: 3,
            minCapacity: 0,
            resourceId: Token.asString(
              Fn.format("autoScalingGroup/%s", [example.name])
            ),
            scalableDimension: "autoscaling:autoScalingGroup:DesiredCapacity",
            serviceNamespace: "autoscaling",
            targetTrackingConfiguration: [
              {
                predefinedScalingMetricSpecification: {
                  predefinedScalingMetricType: "ASGAverageCPUUtilization",
                },
                targetValue: 70,
              },
            ],
          },
        ],
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsAutoscalingplansScalingPlanExample.overrideLogicalId("example");
  }
}

```

### Basic Predictive Scaling

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Fn, Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { AutoscalingGroup } from "./.gen/providers/aws/autoscaling-group";
import { AutoscalingplansScalingPlan } from "./.gen/providers/aws/autoscalingplans-scaling-plan";
import { DataAwsAvailabilityZones } from "./.gen/providers/aws/data-aws-availability-zones";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const available = new DataAwsAvailabilityZones(this, "available", {});
    const example = new AutoscalingGroup(this, "example", {
      availabilityZones: [
        Token.asString(Fn.lookupNested(available.names, ["0"])),
      ],
      launchConfiguration: Token.asString(awsLaunchConfigurationExample.name),
      maxSize: 3,
      minSize: 0,
      namePrefix: "example",
      tags: [
        {
          key: "application",
          propagate_at_launch: true,
          value: "example",
        },
      ],
    });
    const awsAutoscalingplansScalingPlanExample =
      new AutoscalingplansScalingPlan(this, "example_2", {
        applicationSource: {
          tagFilter: [
            {
              key: "application",
              values: ["example"],
            },
          ],
        },
        name: "example-predictive-cost-optimization",
        scalingInstruction: [
          {
            disableDynamicScaling: true,
            maxCapacity: 3,
            minCapacity: 0,
            predefinedLoadMetricSpecification: {
              predefinedLoadMetricType: "ASGTotalCPUUtilization",
            },
            predictiveScalingMaxCapacityBehavior:
              "SetForecastCapacityToMaxCapacity",
            predictiveScalingMode: "ForecastAndScale",
            resourceId: Token.asString(
              Fn.format("autoScalingGroup/%s", [example.name])
            ),
            scalableDimension: "autoscaling:autoScalingGroup:DesiredCapacity",
            serviceNamespace: "autoscaling",
            targetTrackingConfiguration: [
              {
                predefinedScalingMetricSpecification: {
                  predefinedScalingMetricType: "ASGAverageCPUUtilization",
                },
                targetValue: 70,
              },
            ],
          },
        ],
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsAutoscalingplansScalingPlanExample.overrideLogicalId("example");
  }
}

```

## Argument Reference

This resource supports the following arguments:

* `name` - (Required) Name of the scaling plan. Names cannot contain vertical bars, colons, or forward slashes.
* `applicationSource` - (Required) CloudFormation stack or set of tags. You can create one scaling plan per application source.
* `scalingInstruction` - (Required) Scaling instructions. More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_ScalingInstruction.html).

The `applicationSource` object supports the following:

* `cloudformationStackArn` - (Optional) ARN of a AWS CloudFormation stack.
* `tagFilter` - (Optional) Set of tags.

The `tagFilter` object supports the following:

* `key` - (Required) Tag key.
* `values` - (Optional) Tag values.

The `scalingInstruction` object supports the following:

* `maxCapacity` - (Required) Maximum capacity of the resource. The exception to this upper limit is if you specify a non-default setting for `predictiveScalingMaxCapacityBehavior`.
* `minCapacity` - (Required) Minimum capacity of the resource.
* `resourceId` - (Required) ID of the resource. This string consists of the resource type and unique identifier.
* `scalableDimension` - (Required) Scalable dimension associated with the resource. Valid values: `autoscaling:autoScalingGroup:DesiredCapacity`, `dynamodb:index:ReadCapacityUnits`, `dynamodb:index:WriteCapacityUnits`, `dynamodb:table:ReadCapacityUnits`, `dynamodb:table:WriteCapacityUnits`, `ecs:service:DesiredCount`, `ec2:spot-fleet-request:TargetCapacity`, `rds:cluster:ReadReplicaCount`.
* `serviceNamespace` - (Required) Namespace of the AWS service. Valid values: `autoscaling`, `dynamodb`, `ecs`, `ec2`, `rds`.
* `targetTrackingConfiguration` - (Required) Structure that defines new target tracking configurations. Each of these structures includes a specific scaling metric and a target value for the metric, along with various parameters to use with dynamic scaling.
More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_TargetTrackingConfiguration.html).
* `customizedLoadMetricSpecification` - (Optional) Customized load metric to use for predictive scaling. You must specify either `customizedLoadMetricSpecification` or `predefinedLoadMetricSpecification` when configuring predictive scaling.
More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_CustomizedLoadMetricSpecification.html).
* `disableDynamicScaling` - (Optional) Boolean controlling whether dynamic scaling by AWS Auto Scaling is disabled. Defaults to `false`.
* `predefinedLoadMetricSpecification` - (Optional) Predefined load metric to use for predictive scaling. You must specify either `predefinedLoadMetricSpecification` or `customizedLoadMetricSpecification` when configuring predictive scaling.
More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_PredefinedLoadMetricSpecification.html).
* `predictiveScalingMaxCapacityBehavior`- (Optional) Defines the behavior that should be applied if the forecast capacity approaches or exceeds the maximum capacity specified for the resource.
Valid values: `SetForecastCapacityToMaxCapacity`, `SetMaxCapacityAboveForecastCapacity`, `SetMaxCapacityToForecastCapacity`.
* `predictiveScalingMaxCapacityBuffer` - (Optional) Size of the capacity buffer to use when the forecast capacity is close to or exceeds the maximum capacity.
* `predictiveScalingMode` - (Optional) Predictive scaling mode. Valid values: `ForecastAndScale`, `ForecastOnly`.
* `scalingPolicyUpdateBehavior` - (Optional) Controls whether a resource's externally created scaling policies are kept or replaced. Valid values: `KeepExternalPolicies`, `ReplaceExternalPolicies`. Defaults to `KeepExternalPolicies`.
* `scheduledActionBufferTime` - (Optional) Amount of time, in seconds, to buffer the run time of scheduled scaling actions when scaling out.

The `customizedLoadMetricSpecification` object supports the following:

* `metricName` - (Required) Name of the metric.
* `namespace` - (Required) Namespace of the metric.
* `statistic` - (Required) Statistic of the metric. Currently, the value must always be `Sum`.
* `dimensions` - (Optional) Dimensions of the metric.
* `unit` - (Optional) Unit of the metric.

The `predefinedLoadMetricSpecification` object supports the following:

* `predefinedLoadMetricType` - (Required) Metric type. Valid values: `ALBTargetGroupRequestCount`, `ASGTotalCPUUtilization`, `ASGTotalNetworkIn`, `ASGTotalNetworkOut`.
* `resourceLabel` - (Optional) Identifies the resource associated with the metric type.

The `targetTrackingConfiguration` object supports the following:

* `targetValue` - (Required) Target value for the metric.
* `customizedScalingMetricSpecification` - (Optional) Customized metric. You can specify either `customizedScalingMetricSpecification` or `predefinedScalingMetricSpecification`.
More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_CustomizedScalingMetricSpecification.html).
* `disableScaleIn` - (Optional) Boolean indicating whether scale in by the target tracking scaling policy is disabled. Defaults to `false`.
* `predefinedScalingMetricSpecification` - (Optional) Predefined metric. You can specify either `predefinedScalingMetricSpecification` or `customizedScalingMetricSpecification`.
More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_PredefinedScalingMetricSpecification.html).
* `estimatedInstanceWarmup` - (Optional) Estimated time, in seconds, until a newly launched instance can contribute to the CloudWatch metrics.
This value is used only if the resource is an Auto Scaling group.
* `scaleInCooldown` - (Optional) Amount of time, in seconds, after a scale in activity completes before another scale in activity can start.
This value is not used if the scalable resource is an Auto Scaling group.
* `scaleOutCooldown` - (Optional) Amount of time, in seconds, after a scale-out activity completes before another scale-out activity can start.
This value is not used if the scalable resource is an Auto Scaling group.

The `customizedScalingMetricSpecification` object supports the following:

* `metricName` - (Required) Name of the metric.
* `namespace` - (Required) Namespace of the metric.
* `statistic` - (Required) Statistic of the metric. Valid values: `Average`, `Maximum`, `Minimum`, `SampleCount`, `Sum`.
* `dimensions` - (Optional) Dimensions of the metric.
* `unit` - (Optional) Unit of the metric.

The `predefinedScalingMetricSpecification` object supports the following:

* `predefinedScalingMetricType` - (Required) Metric type. Valid values: `ALBRequestCountPerTarget`, `ASGAverageCPUUtilization`, `ASGAverageNetworkIn`, `ASGAverageNetworkOut`, `DynamoDBReadCapacityUtilization`, `DynamoDBWriteCapacityUtilization`, `ECSServiceAverageCPUUtilization`, `ECSServiceAverageMemoryUtilization`, `EC2SpotFleetRequestAverageCPUUtilization`, `EC2SpotFleetRequestAverageNetworkIn`, `EC2SpotFleetRequestAverageNetworkOut`, `RDSReaderAverageCPUUtilization`, `RDSReaderAverageDatabaseConnections`.
* `resourceLabel` - (Optional) Identifies the resource associated with the metric type.

## Attribute Reference

This resource exports the following attributes in addition to the arguments above:

* `id` - Scaling plan identifier.
* `scalingPlanVersion` - The version number of the scaling plan. This value is always 1.

## Import

In Terraform v1.5.0 and later, use an [`import` block](https://developer.hashicorp.com/terraform/language/import) to import Auto Scaling scaling plans using the `name`. For example:

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { AutoscalingplansScalingPlan } from "./.gen/providers/aws/autoscalingplans-scaling-plan";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    AutoscalingplansScalingPlan.generateConfigForImport(
      this,
      "example",
      "MyScale1"
    );
  }
}

```

Using `terraform import`, import Auto Scaling scaling plans using the `name`. For example:

```console
% terraform import aws_autoscalingplans_scaling_plan.example MyScale1
```

<!-- cache-key: cdktf-0.20.8 input-f67f35037f518287955e616d7a36d30ef67c9f228d87872a4d2e00fce74eaaef -->