---
subcategory: "RDS (Relational Database)"
layout: "aws"
page_title: "AWS: aws_rds_global_cluster"
description: |-
  Manages an RDS Global Cluster
---


<!-- Please do not edit this file, it is generated. -->
# Resource: aws_rds_global_cluster

Manages an RDS Global Cluster, which is an Aurora global database spread across multiple regions. The global database contains a single primary cluster with read-write capability, and a read-only secondary cluster that receives data from the primary cluster through high-speed replication performed by the Aurora storage subsystem.

More information about Aurora global databases can be found in the [Aurora User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html#aurora-global-database-creating).

## Example Usage

### New MySQL Global Cluster

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { RdsCluster } from "./.gen/providers/aws/rds-cluster";
import { RdsClusterInstance } from "./.gen/providers/aws/rds-cluster-instance";
import { RdsGlobalCluster } from "./.gen/providers/aws/rds-global-cluster";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const example = new RdsGlobalCluster(this, "example", {
      databaseName: "example_db",
      engine: "aurora",
      engineVersion: "5.6.mysql_aurora.1.22.2",
      globalClusterIdentifier: "global-test",
    });
    const primary = new RdsCluster(this, "primary", {
      clusterIdentifier: "test-primary-cluster",
      databaseName: "example_db",
      dbSubnetGroupName: "default",
      engine: example.engine,
      engineVersion: example.engineVersion,
      globalClusterIdentifier: example.id,
      masterPassword: "somepass123",
      masterUsername: "username",
      provider: awsPrimary,
    });
    const awsRdsClusterInstancePrimary = new RdsClusterInstance(
      this,
      "primary_2",
      {
        clusterIdentifier: primary.id,
        dbSubnetGroupName: "default",
        engine: example.engine,
        engineVersion: example.engineVersion,
        identifier: "test-primary-cluster-instance",
        instanceClass: "db.r4.large",
        provider: awsPrimary,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsRdsClusterInstancePrimary.overrideLogicalId("primary");
    const secondary = new RdsCluster(this, "secondary", {
      clusterIdentifier: "test-secondary-cluster",
      dbSubnetGroupName: "default",
      dependsOn: [awsRdsClusterInstancePrimary],
      engine: example.engine,
      engineVersion: example.engineVersion,
      globalClusterIdentifier: example.id,
      provider: awsSecondary,
    });
    const awsRdsClusterInstanceSecondary = new RdsClusterInstance(
      this,
      "secondary_4",
      {
        clusterIdentifier: secondary.id,
        dbSubnetGroupName: "default",
        engine: example.engine,
        engineVersion: example.engineVersion,
        identifier: "test-secondary-cluster-instance",
        instanceClass: "db.r4.large",
        provider: awsSecondary,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsRdsClusterInstanceSecondary.overrideLogicalId("secondary");
  }
}

```

### New PostgreSQL Global Cluster

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { AwsProvider } from "./.gen/providers/aws/provider";
import { RdsCluster } from "./.gen/providers/aws/rds-cluster";
import { RdsClusterInstance } from "./.gen/providers/aws/rds-cluster-instance";
import { RdsGlobalCluster } from "./.gen/providers/aws/rds-global-cluster";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const primary = new AwsProvider(this, "aws", {
      alias: "primary",
      region: "us-east-2",
    });
    const secondary = new AwsProvider(this, "aws_1", {
      alias: "secondary",
      region: "us-east-1",
    });
    const example = new RdsGlobalCluster(this, "example", {
      databaseName: "example_db",
      engine: "aurora-postgresql",
      engineVersion: "11.9",
      globalClusterIdentifier: "global-test",
    });
    const awsRdsClusterPrimary = new RdsCluster(this, "primary", {
      clusterIdentifier: "test-primary-cluster",
      databaseName: "example_db",
      dbSubnetGroupName: "default",
      engine: example.engine,
      engineVersion: example.engineVersion,
      globalClusterIdentifier: example.id,
      masterPassword: "somepass123",
      masterUsername: "username",
      provider: primary,
    });
    const awsRdsClusterInstancePrimary = new RdsClusterInstance(
      this,
      "primary_4",
      {
        clusterIdentifier: Token.asString(awsRdsClusterPrimary.id),
        dbSubnetGroupName: "default",
        engine: example.engine,
        engineVersion: example.engineVersion,
        identifier: "test-primary-cluster-instance",
        instanceClass: "db.r4.large",
        provider: primary,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsRdsClusterInstancePrimary.overrideLogicalId("primary");
    const awsRdsClusterSecondary = new RdsCluster(this, "secondary", {
      clusterIdentifier: "test-secondary-cluster",
      dbSubnetGroupName: "default",
      dependsOn: [awsRdsClusterInstancePrimary],
      engine: example.engine,
      engineVersion: example.engineVersion,
      globalClusterIdentifier: example.id,
      provider: secondary,
      skipFinalSnapshot: true,
    });
    const awsRdsClusterInstanceSecondary = new RdsClusterInstance(
      this,
      "secondary_6",
      {
        clusterIdentifier: Token.asString(awsRdsClusterSecondary.id),
        dbSubnetGroupName: "default",
        engine: example.engine,
        engineVersion: example.engineVersion,
        identifier: "test-secondary-cluster-instance",
        instanceClass: "db.r4.large",
        provider: secondary,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsRdsClusterInstanceSecondary.overrideLogicalId("secondary");
  }
}

```

### New Global Cluster From Existing DB Cluster

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { RdsCluster } from "./.gen/providers/aws/rds-cluster";
import { RdsGlobalCluster } from "./.gen/providers/aws/rds-global-cluster";
interface MyConfig {
  engine: any;
}
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string, config: MyConfig) {
    super(scope, name);
    const example = new RdsCluster(this, "example", {
      lifecycle: {
        ignoreChanges: [globalClusterIdentifier],
      },
      engine: config.engine,
    });
    const awsRdsGlobalClusterExample = new RdsGlobalCluster(this, "example_1", {
      forceDestroy: true,
      globalClusterIdentifier: "example",
      sourceDbClusterIdentifier: example.arn,
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsRdsGlobalClusterExample.overrideLogicalId("example");
  }
}

```

### Upgrading Engine Versions

When you upgrade the version of an `aws_rds_global_cluster`, Terraform will attempt to in-place upgrade the engine versions of all associated clusters. Since the `aws_rds_cluster` resource is being updated through the `aws_rds_global_cluster`, you are likely to get an error (`Provider produced inconsistent final plan`). To avoid this, use the `lifecycle` `ignore_changes` meta argument as shown below on the `aws_rds_cluster`.

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { RdsCluster } from "./.gen/providers/aws/rds-cluster";
import { RdsClusterInstance } from "./.gen/providers/aws/rds-cluster-instance";
import { RdsGlobalCluster } from "./.gen/providers/aws/rds-global-cluster";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const example = new RdsGlobalCluster(this, "example", {
      engine: "aurora-mysql",
      engineVersion: "5.7.mysql_aurora.2.07.5",
      globalClusterIdentifier: "kyivkharkiv",
    });
    const primary = new RdsCluster(this, "primary", {
      allowMajorVersionUpgrade: true,
      applyImmediately: true,
      clusterIdentifier: "odessadnipro",
      databaseName: "totoro",
      engine: example.engine,
      engineVersion: example.engineVersion,
      globalClusterIdentifier: example.id,
      lifecycle: {
        ignoreChanges: [engineVersion],
      },
      masterPassword: "satsukimae",
      masterUsername: "maesatsuki",
      skipFinalSnapshot: true,
    });
    const awsRdsClusterInstancePrimary = new RdsClusterInstance(
      this,
      "primary_2",
      {
        applyImmediately: true,
        clusterIdentifier: primary.id,
        engine: primary.engine,
        engineVersion: primary.engineVersion,
        identifier: "donetsklviv",
        instanceClass: "db.r4.large",
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsRdsClusterInstancePrimary.overrideLogicalId("primary");
  }
}

```

## Argument Reference

This resource supports the following arguments:

* `globalClusterIdentifier` - (Required, Forces new resources) Global cluster identifier.
* `databaseName` - (Optional, Forces new resources) Name for an automatically created database on cluster creation.
* `deletionProtection` - (Optional) If the Global Cluster should have deletion protection enabled. The database can't be deleted when this value is set to `true`. The default is `false`.
* `engine` - (Optional, Forces new resources) Name of the database engine to be used for this DB cluster. Terraform will only perform drift detection if a configuration value is provided. Valid values: `aurora`, `aurora-mysql`, `aurora-postgresql`. Defaults to `aurora`. Conflicts with `sourceDbClusterIdentifier`.
* `engineLifecycleSupport` - (Optional) The life cycle type for this DB instance. This setting applies only to Aurora PostgreSQL-based global databases. Valid values are `open-source-rds-extended-support`, `open-source-rds-extended-support-disabled`. Default value is `open-source-rds-extended-support`. [Using Amazon RDS Extended Support]: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/extended-support.html
* `engineVersion` - (Optional) Engine version of the Aurora global database. The `engine`, `engineVersion`, and `instanceClass` (on the `aws_rds_cluster_instance`) must together support global databases. See [Using Amazon Aurora global databases](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html) for more information. By upgrading the engine version, Terraform will upgrade cluster members. **NOTE:** To avoid an `inconsistent final plan` error while upgrading, use the `lifecycle` `ignore_changes` for `engineVersion` meta argument on the associated `aws_rds_cluster` resource as shown above in [Upgrading Engine Versions](#upgrading-engine-versions) example.
* `forceDestroy` - (Optional) Enable to remove DB Cluster members from Global Cluster on destroy. Required with `sourceDbClusterIdentifier`.
* `sourceDbClusterIdentifier` - (Optional) Amazon Resource Name (ARN) to use as the primary DB Cluster of the Global Cluster on creation. Terraform cannot perform drift detection of this value.
* `storageEncrypted` - (Optional, Forces new resources) Specifies whether the DB cluster is encrypted. The default is `false` unless `sourceDbClusterIdentifier` is specified and encrypted. Terraform will only perform drift detection if a configuration value is provided.

## Attribute Reference

This resource exports the following attributes in addition to the arguments above:

* `arn` - RDS Global Cluster Amazon Resource Name (ARN)
* `globalClusterMembers` - Set of objects containing Global Cluster members.
    * `db_cluster_arn` - Amazon Resource Name (ARN) of member DB Cluster
    * `is_writer` - Whether the member is the primary DB Cluster
* `globalClusterResourceId` - AWS Region-unique, immutable identifier for the global database cluster. This identifier is found in AWS CloudTrail log entries whenever the AWS KMS key for the DB cluster is accessed
* `id` - RDS Global Cluster identifier

## Timeouts

[Configuration options](https://developer.hashicorp.com/terraform/language/resources/syntax#operation-timeouts):

- `create` - (Default `30m`)
- `update` - (Default `90m`)
- `delete` - (Default `30m`)

## Import

In Terraform v1.5.0 and later, use an [`import` block](https://developer.hashicorp.com/terraform/language/import) to import `aws_rds_global_cluster` using the RDS Global Cluster identifier. For example:

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { RdsGlobalCluster } from "./.gen/providers/aws/rds-global-cluster";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    RdsGlobalCluster.generateConfigForImport(this, "example", "example");
  }
}

```

Using `terraform import`, import `aws_rds_global_cluster` using the RDS Global Cluster identifier. For example:

```console
% terraform import aws_rds_global_cluster.example example
```

Certain resource arguments, like `forceDestroy`, only exist within Terraform. If the argument is set in the Terraform configuration on an imported resource, Terraform will show a difference on the first plan after import to update the state value. This change is safe to apply immediately so the state matches the desired configuration.

Certain resource arguments, like `sourceDbClusterIdentifier`, do not have an API method for reading the information after creation. If the argument is set in the Terraform configuration on an imported resource, Terraform will always show a difference. To workaround this behavior, either omit the argument from the Terraform configuration or use [`ignore_changes`](https://www.terraform.io/docs/configuration/meta-arguments/lifecycle.html#ignore_changes) to hide the difference. For example:

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { RdsGlobalCluster } from "./.gen/providers/aws/rds-global-cluster";
interface MyConfig {
  globalClusterIdentifier: any;
}
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string, config: MyConfig) {
    super(scope, name);
    new RdsGlobalCluster(this, "example", {
      lifecycle: {
        ignoreChanges: [sourceDbClusterIdentifier],
      },
      globalClusterIdentifier: config.globalClusterIdentifier,
    });
  }
}

```

<!-- cache-key: cdktf-0.20.1 input-63ed2a954c6852f58da2c116d6c114fff786c66e1d260cfae7f97136013f0c8e -->