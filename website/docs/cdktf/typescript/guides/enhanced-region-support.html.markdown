---
subcategory: ""
layout: "aws"
page_title: "Terraform AWS Provider Enhanced Region Support"
description: |-
  Enhanced Region support with the Terraform AWS Provider.
---


<!-- Please do not edit this file, it is generated. -->
# Enhanced Region Support

Version 6.0.0 of the Terraform AWS Provider adds `region` to most resources making it significantly easier to manage infrastructure across AWS Regions without requiring multiple provider configurations.

<!-- TOC depthFrom:2 depthTo:2 -->

- [What's new](#whats-new)
- [What's not changing](#whats-not-changing)
- [Can I use `region` in every resource?](#can-i-use-region-in-every-resource)
- [Why make this change](#why-make-this-change)
- [How `region` works](#how-region-works)
- [Migrating from multiple provider configurations](#migrating-from-multiple-provider-configurations)
- [Before and after examples using `region`](#before-and-after-examples-using-region)
- [Non–region-aware resources](#nonregion-aware-resources)

<!-- /TOC -->

## What's new

As of v6.0.0, most existing resources, data sources, and ephemeral resources are now [Region-aware](#nonregion-aware-resources), meaning they support a new top-level `region`. This allows you to manage a resource in a Region different from the one specified in the provider configuration without requiring multiple provider blocks. See [How `region` works](#how-region-works) for details.

For example, if your provider is configured for `us-east-1`, you can now manage a VPC in `us-west-2` without defining an additional provider block:

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { Vpc } from "./.gen/providers/aws/vpc";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new Vpc(this, "peer", {
      cidrBlock: "10.1.0.0/16",
      region: "us-west-2",
    });
  }
}

```

## What's _not_ changing

_Pre-v6.0.0 configurations that use provider blocks per Region remain valid in v6.0.0 and are not deprecated._

You can still define the Region at the provider level using any of the existing methods—for example, through the AWS [config file](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html), [provider configuration](https://developer.hashicorp.com/terraform/language/providers/configuration), [environment variables](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#environment-variables), [shared configuration files](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#shared-configuration-and-credentials-files), or explicitly using the `provider`’s [`region`](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#region).

## Can I use `region` in every resource?

No. While most resources are now Region-aware, there are exceptions. These include a few resources that already had a `region` and resources that are inherently global. See [Non–region-aware resources](#nonregion-aware-resources).

## Why make this change

Before version 6.0.0, managing infrastructure across multiple Regions required a separate provider configuration for each Region. This approach led to complex and repetitive configurations, especially for large infrastructures—AWS currently operates in [36 Regions](https://aws.amazon.com/about-aws/global-infrastructure/), with more announced. Additionally, each provider configuration adds overhead in terms of memory and compute resources.

See the [examples](#before-and-after-examples-using-region) below for a comparison of configurations before and after introducing `region`.

## How `region` works

The new top-level `region` is [_Optional_ and _Computed_](https://developer.hashicorp.com/terraform/plugin/framework/handling-data/attributes/string#configurability), and defaults to the Region specified in the provider configuration. Its value is validated to ensure it belongs to the configured [partition](https://docs.aws.amazon.com/whitepapers/latest/aws-fault-isolation-boundaries/partitions.html). **Changing the value of `region` will force resource replacement.**

To [import](https://developer.hashicorp.com/terraform/cli/import) a resource in a specific Region, append `@<region>` to the [import ID](https://developer.hashicorp.com/terraform/language/import#import-id)—for example:

```sh
terraform import aws_vpc.test_vpc vpc-a01106c2@eu-west-1
```

## Migrating from multiple provider configurations

To migrate from a separate provider configuration for each Region to a single provider configuration block and per-resource `region` values you must ensure that Terraform state is refreshed before editing resource configuration:

1. Upgrade to v6.0.0
2. Run a Terraform apply in [refresh-only mode](https://developer.hashicorp.com/terraform/cli/commands/plan#planning-modes) -- `terraform apply -refresh-only`
3. Modify the affected resource configurations, replacing the [`provider` meta-argument](https://developer.hashicorp.com/terraform/language/meta-arguments/resource-provider) with a `region` argument

## Before and after examples using `region`

### Cross-region VPC peering

<details>
<summary>Before, Pre-v6.0.0</summary>
<p>

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { DataAwsCallerIdentity } from "./.gen/providers/aws/data-aws-caller-identity";
import { AwsProvider } from "./.gen/providers/aws/provider";
import { Vpc } from "./.gen/providers/aws/vpc";
import { VpcPeeringConnection } from "./.gen/providers/aws/vpc-peering-connection";
import { VpcPeeringConnectionAccepterA } from "./.gen/providers/aws/vpc-peering-connection-accepter";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new AwsProvider(this, "aws", {
      region: "us-east-1",
    });
    const peer = new AwsProvider(this, "aws_1", {
      alias: "peer",
      region: "us-west-2",
    });
    const main = new Vpc(this, "main", {
      cidrBlock: "10.0.0.0/16",
    });
    const awsVpcPeer = new Vpc(this, "peer", {
      cidrBlock: "10.1.0.0/16",
      provider: peer,
    });
    const dataAwsCallerIdentityPeer = new DataAwsCallerIdentity(
      this,
      "peer_4",
      {
        provider: peer,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    dataAwsCallerIdentityPeer.overrideLogicalId("peer");
    const awsVpcPeeringConnectionPeer = new VpcPeeringConnection(
      this,
      "peer_5",
      {
        autoAccept: false,
        peerOwnerId: Token.asString(dataAwsCallerIdentityPeer.accountId),
        peerRegion: "us-west-2",
        peerVpcId: Token.asString(awsVpcPeer.id),
        vpcId: main.id,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsVpcPeeringConnectionPeer.overrideLogicalId("peer");
    const awsVpcPeeringConnectionAccepterPeer =
      new VpcPeeringConnectionAccepterA(this, "peer_6", {
        autoAccept: true,
        provider: peer,
        vpcPeeringConnectionId: Token.asString(awsVpcPeeringConnectionPeer.id),
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsVpcPeeringConnectionAccepterPeer.overrideLogicalId("peer");
  }
}

```

</p>
</details>

<details>
<summary>After, v6.0.0+</summary>
<p>

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { AwsProvider } from "./.gen/providers/aws/provider";
import { Vpc } from "./.gen/providers/aws/vpc";
import { VpcPeeringConnection } from "./.gen/providers/aws/vpc-peering-connection";
import { VpcPeeringConnectionAccepterA } from "./.gen/providers/aws/vpc-peering-connection-accepter";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new AwsProvider(this, "aws", {
      region: "us-east-1",
    });
    const main = new Vpc(this, "main", {
      cidrBlock: "10.0.0.0/16",
    });
    const peer = new Vpc(this, "peer", {
      cidrBlock: "10.1.0.0/16",
      region: "us-west-2",
    });
    const awsVpcPeeringConnectionPeer = new VpcPeeringConnection(
      this,
      "peer_3",
      {
        autoAccept: false,
        peerRegion: "us-west-2",
        peerVpcId: peer.id,
        vpcId: main.id,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsVpcPeeringConnectionPeer.overrideLogicalId("peer");
    const awsVpcPeeringConnectionAccepterPeer =
      new VpcPeeringConnectionAccepterA(this, "peer_4", {
        autoAccept: true,
        region: "us-west-2",
        vpcPeeringConnectionId: Token.asString(awsVpcPeeringConnectionPeer.id),
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsVpcPeeringConnectionAccepterPeer.overrideLogicalId("peer");
  }
}

```

</p>
</details>

### KMS replica key

<details>
<summary>Before, Pre-v6.0.0</summary>
<p>

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { KmsKey } from "./.gen/providers/aws/kms-key";
import { KmsReplicaKey } from "./.gen/providers/aws/kms-replica-key";
import { AwsProvider } from "./.gen/providers/aws/provider";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const primary = new AwsProvider(this, "aws", {
      alias: "primary",
      region: "us-east-1",
    });
    new AwsProvider(this, "aws_1", {
      region: "us-west-2",
    });
    const awsKmsKeyPrimary = new KmsKey(this, "primary", {
      deletionWindowInDays: 30,
      description: "Multi-Region primary key",
      multiRegion: true,
      provider: primary,
    });
    new KmsReplicaKey(this, "replica", {
      deletionWindowInDays: 7,
      description: "Multi-Region replica key",
      primaryKeyArn: Token.asString(awsKmsKeyPrimary.arn),
    });
  }
}

```

</p>
</details>

<details>
<summary>After, v6.0.0</summary>
<p>

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { KmsKey } from "./.gen/providers/aws/kms-key";
import { KmsReplicaKey } from "./.gen/providers/aws/kms-replica-key";
import { AwsProvider } from "./.gen/providers/aws/provider";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new AwsProvider(this, "aws", {
      region: "us-west-2",
    });
    const primary = new KmsKey(this, "primary", {
      deletionWindowInDays: 30,
      description: "Multi-Region primary key",
      multiRegion: true,
      region: "us-east-1",
    });
    new KmsReplicaKey(this, "replica", {
      deletionWindowInDays: 7,
      description: "Multi-Region replica key",
      primaryKeyArn: primary.arn,
    });
  }
}

```

</p>
</details>

### S3 bucket replication configuration

<details>
<summary>Before, Pre-v6.0.0</summary>
<p>

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { DataAwsIamPolicyDocument } from "./.gen/providers/aws/data-aws-iam-policy-document";
import { IamPolicy } from "./.gen/providers/aws/iam-policy";
import { IamRole } from "./.gen/providers/aws/iam-role";
import { IamRolePolicyAttachment } from "./.gen/providers/aws/iam-role-policy-attachment";
import { AwsProvider } from "./.gen/providers/aws/provider";
import { S3Bucket } from "./.gen/providers/aws/s3-bucket";
import { S3BucketAcl } from "./.gen/providers/aws/s3-bucket-acl";
import { S3BucketReplicationConfigurationA } from "./.gen/providers/aws/s3-bucket-replication-configuration";
import { S3BucketVersioningA } from "./.gen/providers/aws/s3-bucket-versioning";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new AwsProvider(this, "aws", {
      region: "eu-west-1",
    });
    const central = new AwsProvider(this, "aws_1", {
      alias: "central",
      region: "eu-central-1",
    });
    const destination = new S3Bucket(this, "destination", {
      bucket: "tf-test-bucket-destination-12345",
    });
    const source = new S3Bucket(this, "source", {
      bucket: "tf-test-bucket-source-12345",
      provider: central,
    });
    new S3BucketAcl(this, "source_bucket_acl", {
      acl: "private",
      bucket: source.id,
      provider: central,
    });
    const awsS3BucketVersioningDestination = new S3BucketVersioningA(
      this,
      "destination_5",
      {
        bucket: destination.id,
        versioningConfiguration: {
          status: "Enabled",
        },
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsS3BucketVersioningDestination.overrideLogicalId("destination");
    const awsS3BucketVersioningSource = new S3BucketVersioningA(
      this,
      "source_6",
      {
        bucket: source.id,
        provider: central,
        versioningConfiguration: {
          status: "Enabled",
        },
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsS3BucketVersioningSource.overrideLogicalId("source");
    const assumeRole = new DataAwsIamPolicyDocument(this, "assume_role", {
      statement: [
        {
          actions: ["sts:AssumeRole"],
          effect: "Allow",
          principals: [
            {
              identifiers: ["s3.amazonaws.com"],
              type: "Service",
            },
          ],
        },
      ],
    });
    const replication = new DataAwsIamPolicyDocument(this, "replication", {
      statement: [
        {
          actions: ["s3:GetReplicationConfiguration", "s3:ListBucket"],
          effect: "Allow",
          resources: [source.arn],
        },
        {
          actions: [
            "s3:GetObjectVersionForReplication",
            "s3:GetObjectVersionAcl",
            "s3:GetObjectVersionTagging",
          ],
          effect: "Allow",
          resources: ["${" + source.arn + "}/*"],
        },
        {
          actions: [
            "s3:ReplicateObject",
            "s3:ReplicateDelete",
            "s3:ReplicateTags",
          ],
          effect: "Allow",
          resources: ["${" + destination.arn + "}/*"],
        },
      ],
    });
    const awsIamPolicyReplication = new IamPolicy(this, "replication_9", {
      name: "tf-iam-role-policy-replication-12345",
      policy: Token.asString(replication.json),
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamPolicyReplication.overrideLogicalId("replication");
    const awsIamRoleReplication = new IamRole(this, "replication_10", {
      assumeRolePolicy: Token.asString(assumeRole.json),
      name: "tf-iam-role-replication-12345",
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamRoleReplication.overrideLogicalId("replication");
    const awsIamRolePolicyAttachmentReplication = new IamRolePolicyAttachment(
      this,
      "replication_11",
      {
        policyArn: Token.asString(awsIamPolicyReplication.arn),
        role: Token.asString(awsIamRoleReplication.name),
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamRolePolicyAttachmentReplication.overrideLogicalId("replication");
    const awsS3BucketReplicationConfigurationReplication =
      new S3BucketReplicationConfigurationA(this, "replication_12", {
        bucket: source.id,
        dependsOn: [awsS3BucketVersioningSource],
        provider: central,
        role: Token.asString(awsIamRoleReplication.arn),
        rule: [
          {
            destination: {
              bucket: destination.arn,
              storageClass: "STANDARD",
            },
            filter: {
              prefix: "example",
            },
            id: "examplerule",
            status: "Enabled",
          },
        ],
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsS3BucketReplicationConfigurationReplication.overrideLogicalId(
      "replication"
    );
  }
}

```

</p>
</details>

<details>
<summary>After, v6.0.0</summary>
<p>

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { DataAwsIamPolicyDocument } from "./.gen/providers/aws/data-aws-iam-policy-document";
import { IamPolicy } from "./.gen/providers/aws/iam-policy";
import { IamRole } from "./.gen/providers/aws/iam-role";
import { IamRolePolicyAttachment } from "./.gen/providers/aws/iam-role-policy-attachment";
import { AwsProvider } from "./.gen/providers/aws/provider";
import { S3Bucket } from "./.gen/providers/aws/s3-bucket";
import { S3BucketAcl } from "./.gen/providers/aws/s3-bucket-acl";
import { S3BucketReplicationConfigurationA } from "./.gen/providers/aws/s3-bucket-replication-configuration";
import { S3BucketVersioningA } from "./.gen/providers/aws/s3-bucket-versioning";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new AwsProvider(this, "aws", {
      region: "eu-west-1",
    });
    const destination = new S3Bucket(this, "destination", {
      bucket: "tf-test-bucket-destination-12345",
    });
    const source = new S3Bucket(this, "source", {
      bucket: "tf-test-bucket-source-12345",
      region: "eu-central-1",
    });
    new S3BucketAcl(this, "source_bucket_acl", {
      acl: "private",
      bucket: source.id,
      region: "eu-central-1",
    });
    const awsS3BucketVersioningDestination = new S3BucketVersioningA(
      this,
      "destination_4",
      {
        bucket: destination.id,
        versioningConfiguration: {
          status: "Enabled",
        },
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsS3BucketVersioningDestination.overrideLogicalId("destination");
    const awsS3BucketVersioningSource = new S3BucketVersioningA(
      this,
      "source_5",
      {
        bucket: source.id,
        region: "eu-central-1",
        versioningConfiguration: {
          status: "Enabled",
        },
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsS3BucketVersioningSource.overrideLogicalId("source");
    const assumeRole = new DataAwsIamPolicyDocument(this, "assume_role", {
      statement: [
        {
          actions: ["sts:AssumeRole"],
          effect: "Allow",
          principals: [
            {
              identifiers: ["s3.amazonaws.com"],
              type: "Service",
            },
          ],
        },
      ],
    });
    const replication = new DataAwsIamPolicyDocument(this, "replication", {
      statement: [
        {
          actions: ["s3:GetReplicationConfiguration", "s3:ListBucket"],
          effect: "Allow",
          resources: [source.arn],
        },
        {
          actions: [
            "s3:GetObjectVersionForReplication",
            "s3:GetObjectVersionAcl",
            "s3:GetObjectVersionTagging",
          ],
          effect: "Allow",
          resources: ["${" + source.arn + "}/*"],
        },
        {
          actions: [
            "s3:ReplicateObject",
            "s3:ReplicateDelete",
            "s3:ReplicateTags",
          ],
          effect: "Allow",
          resources: ["${" + destination.arn + "}/*"],
        },
      ],
    });
    const awsIamPolicyReplication = new IamPolicy(this, "replication_8", {
      name: "tf-iam-role-policy-replication-12345",
      policy: Token.asString(replication.json),
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamPolicyReplication.overrideLogicalId("replication");
    const awsIamRoleReplication = new IamRole(this, "replication_9", {
      assumeRolePolicy: Token.asString(assumeRole.json),
      name: "tf-iam-role-replication-12345",
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamRoleReplication.overrideLogicalId("replication");
    const awsIamRolePolicyAttachmentReplication = new IamRolePolicyAttachment(
      this,
      "replication_10",
      {
        policyArn: Token.asString(awsIamPolicyReplication.arn),
        role: Token.asString(awsIamRoleReplication.name),
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsIamRolePolicyAttachmentReplication.overrideLogicalId("replication");
    const awsS3BucketReplicationConfigurationReplication =
      new S3BucketReplicationConfigurationA(this, "replication_11", {
        bucket: source.id,
        dependsOn: [awsS3BucketVersioningSource],
        region: "eu-central-1",
        role: Token.asString(awsIamRoleReplication.arn),
        rule: [
          {
            destination: {
              bucket: destination.arn,
              storageClass: "STANDARD",
            },
            filter: {
              prefix: "example",
            },
            id: "examplerule",
            status: "Enabled",
          },
        ],
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsS3BucketReplicationConfigurationReplication.overrideLogicalId(
      "replication"
    );
  }
}

```

</p>
</details>

## Non–region-aware resources {#nonregion-aware-resources}

This section lists resources that are not Region-aware—meaning `region` has not been added to them.

Some resources, such as [IAM and STS](https://docs.aws.amazon.com/IAM/latest/UserGuide/programming.html#IAMEndpoints), are [global](https://docs.aws.amazon.com/whitepapers/latest/aws-fault-isolation-boundaries/global-services.html) and exist in all Regions within a partition.

Other resources are not Region-aware because they already had a top-level `region`, are inherently global, or because adding `region` would not be appropriate for other reasons.

### Resources deprecating `region`

The following regional resources and data sources had a top-level `region` prior to version 6.0.0. It is now deprecated and will be replaced in a future version to support the new Region-aware behavior.

* `aws_cloudformation_stack_set_instance` resource
* `aws_config_aggregate_authorization` resource
* `aws_dx_hosted_connection` resource
* `awsRegion` data source
* `aws_s3_bucket` data source
* `aws_servicequotas_template` resource
* `aws_servicequotas_templates` data source
* `aws_ssmincidents_replication_set` resource and data source
* `aws_vpc_endpoint_service` data source
* `aws_vpc_peering_connection` data source

### Global services

All resources for the following services are considered _global_:

* Account Management (`aws_account_*`)
* Billing (`aws_billing_*`)
* Billing and Cost Management Data Exports (`aws_bcmdataexports_*`)
* Budgets (`aws_budgets_*`)
* CloudFront (`aws_cloudfront_*` and `aws_cloudfrontkeyvaluestore_*`)
* Cost Explorer (`aws_ce_*`)
* Cost Optimization Hub (`aws_costoptimizationhub_*`)
* Cost and Usage Report (`aws_cur_*`)
* Global Accelerator (`aws_globalaccelerator_*`)
* IAM (`aws_iam_*`, `aws_rolesanywhere_*` and `aws_caller_identity`)
* Network Manager (`aws_networkmanager_*`)
* Organizations (`aws_organizations_*`)
* Price List (`aws_pricing_*`)
* Route 53 (`aws_route53_*` and `aws_route53domains_*`)
* Route 53 ARC (`aws_route53recoverycontrolconfig_*` and `aws_route53recoveryreadiness_*`)
* Shield Advanced (`aws_shield_*`)
* User Notifications (`aws_notifications_*`)
* User Notifications Contacts (`aws_notificationscontacts_*`)
* WAF Classic (`aws_waf_*`)

### Global resources in regional services

Some regional services have a subset of resources that are global:

| Service | Type | Name |
|---|---|---|
| Backup | Resource | `aws_backup_global_settings` |
| Chime SDK Voice | Resource | `aws_chimesdkvoice_global_settings` |
| CloudTrail | Resource | `aws_cloudtrail_organization_delegated_admin_account` |
| Direct Connect | Resource | `aws_dx_gateway` |
| Direct Connect | Data Source | `aws_dx_gateway` |
| EC2 | Resource | `aws_ec2_image_block_public_access` |
| Firewall Manager | Resource | `aws_fms_admin_account` |
| IPAM | Resource | `aws_vpc_ipam_organization_admin_account` |
| QuickSight | Resource | `aws_quicksight_account_settings` |
| Resource Access Manager | Resource | `aws_ram_sharing_with_organization` |
| S3 | Data Source | `aws_canonical_user_id` |
| S3 | Resource | `aws_s3_account_public_access_block` |
| S3 | Data Source | `aws_s3_account_public_access_block` |
| Service Catalog | Resource | `aws_servicecatalog_organizations_access` |

### Meta data sources

The `aws_default_tags`, `aws_partition`, and `aws_regions` data sources are effectively global.

`region` of the `aws_arn` data source stays as-is.

### Policy Document Data Sources

Some data sources convert HCL into JSON policy documents and are effectively global:

* `aws_cloudwatch_log_data_protection_policy_document`
* `aws_ecr_lifecycle_policy_document`

<!-- cache-key: cdktf-0.20.8 input-575321eb65fe5cc7968914b54535b8d50b7b97b5668f88ce8bf11d9a995e0e04 -->