---
subcategory: "Transit Gateway"
layout: "aws"
page_title: "AWS: aws_ec2_transit_gateway_route_table_routes"
description: |-
   Provides informations for routes of a specific transit gateway
---


<!-- Please do not edit this file, it is generated. -->
# Data Source: aws_ec2_transit_gateway_route_table_routes

Provides informations for routes of a specific transit gateway, such as state, type, cidr

## Example Usage

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { DataAwsEc2TransitGatewayRouteTableRoutes } from "./.gen/providers/aws/data-aws-ec2-transit-gateway-route-table-routes";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    new DataAwsEc2TransitGatewayRouteTableRoutes(this, "test", {
      filter: [
        {
          name: "type",
          values: ["propagated"],
        },
      ],
      transitGatewayRouteTableId: example.id,
    });
  }
}

```

### Complexe use case with transit gateway peering

This example allow to create a mesh of transit gateway for diff√©rent regions routing all traffic to on-prem VPN

```typescript
// DO NOT EDIT. Code generated by 'cdktf convert' - Please report bugs at https://cdk.tf/bug
import { Construct } from "constructs";
import { Token, Fn, TerraformIterator, TerraformStack } from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { DataAwsEc2TransitGatewayRouteTableRoutes } from "./.gen/providers/aws/data-aws-ec2-transit-gateway-route-table-routes";
import { DataAwsEc2TransitGatewayVpcAttachment } from "./.gen/providers/aws/data-aws-ec2-transit-gateway-vpc-attachment";
import { DataAwsEc2TransitGatewayVpcAttachments } from "./.gen/providers/aws/data-aws-ec2-transit-gateway-vpc-attachments";
import { Ec2TransitGateway } from "./.gen/providers/aws/ec2-transit-gateway";
import { Ec2TransitGatewayPeeringAttachment } from "./.gen/providers/aws/ec2-transit-gateway-peering-attachment";
import { Ec2TransitGatewayPeeringAttachmentAccepter } from "./.gen/providers/aws/ec2-transit-gateway-peering-attachment-accepter";
import { Ec2TransitGatewayRoute } from "./.gen/providers/aws/ec2-transit-gateway-route";
import { Ec2TransitGatewayRouteTable } from "./.gen/providers/aws/ec2-transit-gateway-route-table";
import { Ec2TransitGatewayRouteTableAssociation } from "./.gen/providers/aws/ec2-transit-gateway-route-table-association";
import { Ec2TransitGatewayRouteTablePropagation } from "./.gen/providers/aws/ec2-transit-gateway-route-table-propagation";
import { Ec2TransitGatewayVpcAttachment } from "./.gen/providers/aws/ec2-transit-gateway-vpc-attachment";
import { Ec2TransitGatewayVpcAttachmentAccepter } from "./.gen/providers/aws/ec2-transit-gateway-vpc-attachment-accepter";
import { AwsProvider } from "./.gen/providers/aws/provider";
class MyConvertedCode extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    const euCentral1 = new AwsProvider(this, "aws", {
      alias: "eu-central-1",
      region: "eu-central-1",
    });
    const awsEc2TransitGatewayEuCentral1 = new Ec2TransitGateway(
      this,
      "eu-central-1",
      {
        defaultRouteTableAssociation: "disable",
        defaultRouteTablePropagation: "disable",
        provider: euCentral1,
      }
    );
    const thisVar = new Ec2TransitGateway(this, "this", {
      defaultRouteTableAssociation: "disable",
      defaultRouteTablePropagation: "disable",
    });
    const awsEc2TransitGatewayPeeringAttachmentEuCentral1 =
      new Ec2TransitGatewayPeeringAttachment(this, "eu-central-1_3", {
        peerRegion: "eu-central-1",
        peerTransitGatewayId: Token.asString(awsEc2TransitGatewayEuCentral1.id),
        tags: {
          Name: "TGW mesh from eu-central-1",
        },
        transitGatewayId: Token.asString(Fn.lookupNested(thisVar, ["0", "id"])),
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsEc2TransitGatewayPeeringAttachmentEuCentral1.overrideLogicalId(
      "eu-central-1"
    );
    const awsEc2TransitGatewayPeeringAttachmentAccepterEuCentral1 =
      new Ec2TransitGatewayPeeringAttachmentAccepter(this, "eu-central-1_4", {
        provider: euCentral1,
        tags: {
          Name: "Accepter TGW peering eu-central-1",
        },
        transitGatewayAttachmentId: Token.asString(
          awsEc2TransitGatewayPeeringAttachmentEuCentral1.id
        ),
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsEc2TransitGatewayPeeringAttachmentAccepterEuCentral1.overrideLogicalId(
      "eu-central-1"
    );
    const awsEc2TransitGatewayRouteTableEuCentral1 =
      new Ec2TransitGatewayRouteTable(this, "eu-central-1_5", {
        provider: euCentral1,
        tags: Token.asStringMap(
          Fn.merge([
            {
              Name: "wl-transit-gateway-routetable-eu-central-1",
            },
            globalTags,
          ])
        ),
        transitGatewayId: Token.asString(awsEc2TransitGatewayEuCentral1.id),
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsEc2TransitGatewayRouteTableEuCentral1.overrideLogicalId("eu-central-1");
    const awsEc2TransitGatewayRouteTableThis = new Ec2TransitGatewayRouteTable(
      this,
      "this_6",
      {
        transitGatewayId: myTransitGatewayId,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsEc2TransitGatewayRouteTableThis.overrideLogicalId("this");
    new Ec2TransitGatewayRouteTableAssociation(this, "vpn", {
      transitGatewayAttachmentId: Token.asString(
        Fn.lookupNested(awsVpnConnectionThis, [
          "0",
          "transit_gateway_attachment_id",
        ])
      ),
      transitGatewayRouteTableId: myTransitGatewayIdRouteTable,
    });
    const awsEc2TransitGatewayRouteTablePropagationVpn =
      new Ec2TransitGatewayRouteTablePropagation(this, "vpn_8", {
        transitGatewayAttachmentId: Token.asString(
          Fn.lookupNested(awsVpnConnectionThis, [
            "0",
            "transit_gateway_attachment_id",
          ])
        ),
        transitGatewayRouteTableId: Token.asString(
          awsEc2TransitGatewayRouteTableThis.id
        ),
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsEc2TransitGatewayRouteTablePropagationVpn.overrideLogicalId("vpn");
    const awsEc2TransitGatewayVpcAttachmentThis =
      new Ec2TransitGatewayVpcAttachment(this, "this_9", {
        dependsOn: [private, public],
        subnetIds: Token.asList("${[ for s in ${" + private.fqn + "} : s.id]}"),
        transitGatewayDefaultRouteTableAssociation: false,
        transitGatewayDefaultRouteTablePropagation: false,
        transitGatewayId: Token.asString(Fn.lookupNested(thisVar, ["0", "id"])),
        vpcId: Token.asString(awsVpcThis.id),
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsEc2TransitGatewayVpcAttachmentThis.overrideLogicalId("this");
    const filteredEuCentral1 = new DataAwsEc2TransitGatewayVpcAttachments(
      this,
      "filtered-eu-central-1",
      {
        filter: [
          {
            name: "state",
            values: ["pendingAcceptance", "available"],
          },
        ],
        provider: euCentral1,
      }
    );
    new Ec2TransitGatewayRouteTableAssociation(this, "vpc", {
      transitGatewayAttachmentId: Token.asString(
        awsEc2TransitGatewayVpcAttachmentThis.id
      ),
      transitGatewayRouteTableId: myTransitGatewayIdRouteTable,
    });
    const awsEc2TransitGatewayRouteTablePropagationVpc =
      new Ec2TransitGatewayRouteTablePropagation(this, "vpc_12", {
        transitGatewayAttachmentId: Token.asString(
          awsEc2TransitGatewayVpcAttachmentThis.id
        ),
        transitGatewayRouteTableId: Token.asString(
          awsEc2TransitGatewayRouteTableThis.id
        ),
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsEc2TransitGatewayRouteTablePropagationVpc.overrideLogicalId("vpc");
    /*In most cases loops should be handled in the programming language context and 
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const unitEuCentral1ForEachIterator = TerraformIterator.fromList(
      Token.asAny(Fn.toset(filteredEuCentral1.ids))
    );
    const unitEuCentral1 = new DataAwsEc2TransitGatewayVpcAttachment(
      this,
      "unit-eu-central-1",
      {
        id: Token.asString(unitEuCentral1ForEachIterator.value),
        provider: euCentral1,
        forEach: unitEuCentral1ForEachIterator,
      }
    );
    const trustedVpcAttachmentsListEuCentral1 = Fn.compact(
      Token.asList(
        "${[ for k, tva in ${" +
          unitEuCentral1.fqn +
          '} : contains(local.trusted_aws_accounts_ids, lookup(tva, "vpc_owner_id", "")) ? tva.id : ""]}'
      )
    );
    const trustedVpcAttachementsEuCentral1 = Fn.toset(
      Fn.sort(Token.asList(trustedVpcAttachmentsListEuCentral1))
    );
    /*In most cases loops should be handled in the programming language context and 
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const trustedAccountsEuCentral1TgwForEachIterator =
      TerraformIterator.fromList(Token.asAny(trustedVpcAttachementsEuCentral1));
    const trustedAccountsEuCentral1Tgw =
      new Ec2TransitGatewayVpcAttachmentAccepter(
        this,
        "trusted_accounts_eu-central-1_tgw",
        {
          lifecycle: {
            ignoreChanges: [
              subnetIds,
              id,
              dnsSupport,
              securityGroupReferencingSupport,
              ipv6Support,
              transitGatewayId,
              vpcId,
              vpcOwnerId,
            ],
            preventDestroy: false,
          },
          provider: euCentral1,
          tags: Token.asStringMap(globalTags),
          transitGatewayAttachmentId: Token.asString(
            trustedAccountsEuCentral1TgwForEachIterator.value
          ),
          transitGatewayDefaultRouteTableAssociation: false,
          transitGatewayDefaultRouteTablePropagation: false,
          forEach: trustedAccountsEuCentral1TgwForEachIterator,
        }
      );
    /*In most cases loops should be handled in the programming language context and 
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const trustedAccountsEuCentral1ForEachIterator = TerraformIterator.fromList(
      Token.asAny(trustedAccountsEuCentral1Tgw)
    );
    new Ec2TransitGatewayRouteTableAssociation(
      this,
      "trusted_accounts_eu-central-1",
      {
        provider: euCentral1,
        transitGatewayAttachmentId: Token.asString(
          Fn.lookupNested(trustedAccountsEuCentral1ForEachIterator.value, [
            "transit_gateway_attachment_id",
          ])
        ),
        transitGatewayRouteTableId: Token.asString(
          awsEc2TransitGatewayRouteTableEuCentral1.id
        ),
        forEach: trustedAccountsEuCentral1ForEachIterator,
      }
    );
    /*In most cases loops should be handled in the programming language context and 
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const awsEc2TransitGatewayRouteTablePropagationTrustedAccountsEuCentral1ForEachIterator =
      TerraformIterator.fromList(Token.asAny(trustedAccountsEuCentral1Tgw));
    const awsEc2TransitGatewayRouteTablePropagationTrustedAccountsEuCentral1 =
      new Ec2TransitGatewayRouteTablePropagation(
        this,
        "trusted_accounts_eu-central-1_16",
        {
          provider: euCentral1,
          transitGatewayAttachmentId: Token.asString(
            Fn.lookupNested(
              awsEc2TransitGatewayRouteTablePropagationTrustedAccountsEuCentral1ForEachIterator.value,
              ["transit_gateway_attachment_id"]
            )
          ),
          transitGatewayRouteTableId: Token.asString(
            awsEc2TransitGatewayRouteTableEuCentral1.id
          ),
          forEach:
            awsEc2TransitGatewayRouteTablePropagationTrustedAccountsEuCentral1ForEachIterator,
        }
      );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsEc2TransitGatewayRouteTablePropagationTrustedAccountsEuCentral1.overrideLogicalId(
      "trusted_accounts_eu-central-1"
    );
    const test = new DataAwsEc2TransitGatewayRouteTableRoutes(this, "test", {
      dependsOn: [
        awsEc2TransitGatewayRouteTablePropagationTrustedAccountsEuCentral1,
      ],
      filter: [
        {
          name: "type",
          values: ["propagated"],
        },
      ],
      provider: euCentral1,
      transitGatewayRouteTableId: Token.asString(
        awsEc2TransitGatewayRouteTableEuCentral1.id
      ),
    });
    /*In most cases loops should be handled in the programming language context and 
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const defaultRegionToEuCentral1ForEachIterator = TerraformIterator.fromList(
      Token.asAny(
        "${{ for r in ${" + test.routes + "} : r.destination_cidr_block => r}}"
      )
    );
    new Ec2TransitGatewayRoute(this, "default-region-to-eu-central-1", {
      destinationCidrBlock: Token.asString(
        defaultRegionToEuCentral1ForEachIterator.key
      ),
      transitGatewayAttachmentId: Token.asString(
        awsEc2TransitGatewayPeeringAttachmentEuCentral1.id
      ),
      transitGatewayRouteTableId: Token.asString(
        awsEc2TransitGatewayRouteTableThis.id
      ),
      forEach: defaultRegionToEuCentral1ForEachIterator,
    });
  }
}

```

## Argument Reference

The following arguments are required:

* `filter` - (Required) Custom filter block as described below.
* `transitGatewayRouteTableId` - (Required) Identifier of EC2 Transit Gateway Route Table.

More complex filters can be expressed using one or more `filter` sub-blocks,
which take the following arguments:

* `name` - (Required) Name of the field to filter by, as defined by
  [the underlying AWS API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SearchTransitGatewayRoutes.html).
* `values` - (Required) Set of values that are accepted for the given field.

## Attributes Reference

In addition to all arguments above, the following attributes are exported:

* `id` - The transit gateway route table id suffixed by `-routes`
* `routes` - List of Transit Gateway Routes.

#### Routes list Attributes Reference

* `destinationCidrBlock` - The CIDR used for route destination matches.
* `prefixListId` - The ID of the prefix list used for destination matches.
* `state` - The current state of the route, can be `active`, `deleted`, `pending`, `blackhole`, `deleting`.
* `transit_gateway_route_table_announcement_id` - The id of the transit gateway route table announcement, most of the time it is an empty string.
* `type` - The type of the route, can be `propagated` or `static`.

<!-- cache-key: cdktf-0.20.8 input-696ba7f42bc4c749cdbe89cddfd24a5aa116e802c8e675cd5c391818b6e6f371 -->